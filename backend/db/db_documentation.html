<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>__init__ API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>db</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import psycopg2
from psycopg2 import pool
import psycopg2.extras
import psycopg2.extensions
from typing import Union, List, Dict, Any, Tuple
import logging
from os.path import join
from os import system
from os import environ as env
from time import time


class DataError(Exception):
    pass


class Database:

    @staticmethod
    def createDatabaseBackup():
        &#34;&#34;&#34; Create (save) backup of current version of the database.
            Saved file names are in format sport_db_backup{timestamp_in_ms}.bak
        &#34;&#34;&#34;
        DB_HOST = env.get(&#34;DB_HOST&#34;)
        DB_NAME = env.get(&#34;DB_NAME&#34;)
        DB_USER = env.get(&#34;DB_USER&#34;)
        DB_PASS = env.get(&#34;DB_PASS&#34;)
        system(f&#39;pg_dump &#34;host={DB_HOST} port=5432 dbname={DB_NAME} user={DB_USER} password={DB_PASS}&#34; &gt; &#39;
               f&#39;db/backups/sport_db_backup{int(round(time() * 1000))}.bak&#39;)

    def __init__(self, dbPool: psycopg2.pool.ThreadedConnectionPool):
        &#34;&#34;&#34; Initialize DB pool and DB logger. &#34;&#34;&#34;

        self.dbPool = dbPool

        LOG_PATH = &#34;logs&#34;
        LOG_FILE = &#34;db&#34;
        name = join(LOG_PATH, LOG_FILE)

        formatter = logging.Formatter(&#39;%(asctime)s %(levelname)-8s %(message)s&#39;)

        handler = logging.FileHandler(name + &#34;.log&#34;, mode=&#39;a&#39;)
        handler.setFormatter(formatter)

        logger = logging.getLogger(name)
        logger.setLevel(logging.DEBUG)
        logger.addHandler(handler)

        self.logger = logger

    def _getConnection(self) -&gt; psycopg2.extensions.connection:
        &#34;&#34;&#34; Establish and return connection from DB pool.

            Returns:
                psycopg2.extensions.connection: DB connection from DB pool
        &#34;&#34;&#34;
        dbConn = self.dbPool.getconn()
        return dbConn

    def _releaseConnection(self, dbConnection: psycopg2.extensions.connection):
        &#34;&#34;&#34; Releases connection.

        Args:
            dbConnection (psycopg2.extensions.connection): database connection
        &#34;&#34;&#34;

        self.dbPool.putconn(dbConnection)

    def getSecretary(self, email: str) -&gt; Union[None, dict]:
        &#34;&#34;&#34; Use in secretary login process.

        Args:
            email (str): entered admin email

        Returns:
            Union[None, dict]: dict of record in DB which email is same as entered email
        &#34;&#34;&#34;

        sql = &#34;select * from users where email=%s and type=&#39;secretary&#39;&#34;
        result = None
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, (email,))
                    result = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getAdmin(self, email: str) -&gt; Union[None, dict]:
        &#34;&#34;&#34; Use in admin login process.

        Args:
            email (str): entered admin email

        Returns:
            Union[None, dict]: dict of record in DB which email is same as entered email
        &#34;&#34;&#34;

        sql = &#34;select * from users where email=%s and type=&#39;admin&#39;&#34;
        result = None
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, (email,))
                    result = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getAllCountries(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;  Returns all active countries from table countries.

        Returns:
            List[Dict[str, Any]]: list of dicts , each dict contains keys name, code
        &#34;&#34;&#34;

        sql = &#34;select code, name from country where is_active = true&#34;
        countries = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        countries.append({&#34;name&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return countries

    def getAllSports(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34; Returns all sports from table sports.

        Returns:
            List[Dict[str, Any]]:  list of dicts , each dict contains keys title, code
        &#34;&#34;&#34;

        sql = &#34;select code, title from sport&#34;
        sports = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        sports.append({&#34;title&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return sports

    def getInactiveCountries(self) -&gt; Dict[str, List[Dict[str, Any]]]:

        &#34;&#34;&#34; Get all inactive countries from table countries.

            Returns:
                dict:  dict with one key = countries, its value is
                list of dicts , each dict contains keys name, code
        &#34;&#34;&#34;

        sql = &#34;select code, name from country where is_active = false&#34;
        result = {&#34;countries&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;countries&#34;].append({&#34;name&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getBranchesWithSports(self) -&gt; List[Dict[str, Any]]:

        &#34;&#34;&#34;  Returns non combi branches from table branch with sport they belong to.

        Returns:
            list:  list of dicts , each dict contains keys sportCode, sportTitle, branchCode, branchTitle.
        &#34;&#34;&#34;

        sql = &#34;select s.code, s.title, b.code, b.title from sport s join branch b on b.sport_id = s.id&#34;
        results = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        results.append(
                            {&#34;sportCode&#34;: tmp[0], &#34;sportTitle&#34;: tmp[1], &#34;branchCode&#34;: tmp[2], &#34;branchTitle&#34;: tmp[3]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return results

    def getFundingData(self, country_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Returns funding data from table funding for selected country.

        Args:
            country_code (str): selected country code

        Returns: Dict[str, List[Dict[str, Any]]]: list of dicts , each dict contains keys branch_id,
        absolute_funding, currency.

        &#34;&#34;&#34;

        sql = &#34;select b.title, f.absolute_funding, f.currency from funding f cross join country c &#34; \
              &#34;join branch b on c.code = %(country_code)s and f.country_id = c.id and b.id = f.branch_id&#34;
        result = {&#34;funding&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;funding&#34;].append({&#34;branch_id&#34;: tmp[0], &#34;absolute_funding&#34;: tmp[1], &#34;currency&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getFundingDistinctCurrencies(self) -&gt; List[str]:
        &#34;&#34;&#34;
            Get list of currencies used in funding data in table funding.

            Returns:
                list: list of strings = currency names.
        &#34;&#34;&#34;

        sql = &#34; select distinct currency from funding where currency != &#39;&#39; &#34;
        results = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
                    cursor.execute(sql)
                    results = cursor.fetchall()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return results

    def getSuccessBySport(self, sport_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Return success records from table success for selected sport.

        Args:
            sport_code (str): code of selected sport

        Returns:
            dict: dict with one key = success, its value is list of dicts, each dict contains
            keys country_name, points, order
        &#34;&#34;&#34;

        sql = &#34;select c.name, suc.points, suc.orders from success suc cross join sport sp &#34; \
              &#34;join country c on suc.sport_id = sp.id and sp.code = %(sport_code)s &#34; \
              &#34;and suc.country_id = c.id order by suc.orders;&#34;
        result = {&#34;success&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_code&#34;: sport_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;success&#34;].append({&#34;country_name&#34;: tmp[0], &#34;points&#34;: tmp[1], &#34;order&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getSuccessByCountry(self, country_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Return success records from table success for selected country.

        Args:
            country_code (str): code of selected country

        Returns:
            dict: dict with one key = success, its value is list of dicts, each dict contains
            keys sport_name, points, order
        &#34;&#34;&#34;

        sql = &#34;select sp.title, suc.points, suc.orders from success suc cross join sport sp &#34; \
              &#34;join country c on suc.sport_id = sp.id and c.code = %(country_code)s &#34; \
              &#34;and suc.country_id = c.id order by suc.orders;&#34;
        result = {&#34;success&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;success&#34;].append({&#34;sport_name&#34;: tmp[0], &#34;points&#34;: tmp[1], &#34;order&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getInterconnectnessData(self, type_id: int, country_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Returns data from table interconnectness for specified country.

                Args:
                    type_id (int): type of intesconnectness, 1 = economic, 2 = non economic
                    country_code (str): code of country

                Returns:
                    dict: dict with one key interconnectness which value is list of dicts with keyscountry, value, type
        &#34;&#34;&#34;

        sql = &#34;select c2.code, c2.name, i.value, it.title  from interconnectness i join country c1 &#34; \
              &#34;on country_one_id = c1.id join country c2 on country_two_id = c2.id join interconnectness_type it &#34; \
              &#34;on i.type_id = it.id where i.type_id = %(type_id)s and c1.code = %(country_code)s &#34;
        result = {&#34;interconnectness&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;type_id&#34;: type_id, &#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;interconnectness&#34;].append(
                            {&#34;code&#34;: tmp[0], &#34;country&#34;: tmp[1], &#34;value&#34;: tmp[2], &#34;type&#34;: tmp[3]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    # inputs to DB

    def addSport(self, code: str, title: str) -&gt; bool:
        &#34;&#34;&#34; Adding a new sport to DB.

            Args:
                code (str): code of new sport
                title (str): title of new sport

            Returns:
                bool: true/false whether sport was successfully added
        &#34;&#34;&#34;
        sql_check = &#34;select * from sport where code = %(code)s&#34;
        sql = &#34;insert into sport(code, title) values (%(code)s, %(title)s);&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_check, {&#34;code&#34;: code})
                    tmp = cursor.fetchone()
                    if tmp is not None:  # sport code already exists
                        self._releaseConnection(dbConn)
                        raise DataError(
                            &#34;unable to insert, sport with entered code already exists, please select another code&#34;)
                    cursor.execute(sql, {&#34;code&#34;: code, &#34;title&#34;: title})
                    dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def addBranch(self, data: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34; Adding a new branch to DB.

            Args:
                data (dict): dict with keys sportCode, branchCode, branchTitle to describe new branch

            Returns:
                bool: true/false whether branch was successfully added
        &#34;&#34;&#34;
        if &#34;sportCode&#34; not in data:
            raise DataError(&#34;sport code missing in data&#34;)

        if &#34;branchCode&#34; not in data:
            raise DataError(&#34;branch code not in data&#34;)

        if &#34;branchTitle&#34; not in data:
            raise DataError(&#34;branch title not in data&#34;)

        sql_sport = &#34;select id from sport where code = %(sport_code)s&#34;
        sql_check = &#34;select s.id, b.title from sport s join branch b on s.id = b.sport_id &#34; \
                    &#34;and s.code = %(sport_code)s and b.code = %(branch_code)s&#34;
        sql = &#34;insert into branch(code, title, is_combined, sport_id) &#34; \
              &#34;values ( %(code)s, %(title)s, %(is_combined)s, %(sport_id)s )&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_sport, {&#34;sport_code&#34;: data[&#34;sportCode&#34;]})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        self._releaseConnection(dbConn)

                        raise DataError(
                            f&#34;unable to insert, sport with entered code doesnt exist, please select another code&#34;)
                    sport_id = tmp[0]

                    cursor.execute(sql_check, {&#34;sport_code&#34;: data[&#39;sportCode&#39;], &#34;branch_code&#34;: data[&#39;branchCode&#39;]})
                    tmp = cursor.fetchone()
                    if tmp is not None:  # branch code already exists
                        self._releaseConnection(dbConn)
                        raise DataError(
                            f&#34;unable to insert, branch with entered code already exists - {tmp[1]}, &#34;
                            f&#34;please select another code&#34;)

                    cursor.execute(sql,
                                   {&#34;code&#34;: data[&#39;branchCode&#39;], &#34;title&#34;: data[&#39;branchTitle&#39;], &#34;is_combined&#34;: &#39;false&#39;,
                                    &#34;sport_id&#34;: sport_id})
                    dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def addCombiBranch(self, data: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34; Adding a new combi branch to DB.

        Args:
            data (dict): dict with items branchCode -&gt; int , branchTitle -&gt; str, countryCode -&gt; str, subBranches -&gt; list
            subbranches value is list of dicts with keys sportCode, branchCode, coefficient which describe subbranch


        Returns:
            bool: true/false whether combi branch was successfully added

        &#34;&#34;&#34;

        if &#34;branchCode&#34; not in data:
            raise DataError(&#34;branch code missing in data&#34;)

        if &#34;branchTitle&#34; not in data:
            raise DataError(&#34;branch title missing in data&#34;)

        if &#34;countryCode&#34; not in data:
            raise DataError(&#34;country code missing in data&#34;)

        if &#34;subBranches&#34; not in data:
            raise DataError(&#34;subBranches data missing&#34;)

        if not isinstance(data[&#34;subBranches&#34;], list):
            raise DataError(&#34;invalid subBranches data structure&#34;)

        suma = 0
        try:
            for i in data[&#34;subBranches&#34;]:
                suma += i[&#34;coefficient&#34;]
            if suma != 1:
                raise DataError(&#34;coefficients sum is not 1&#34;)
        except KeyError:
            try:
                raise DataError(&#34;invalid subbranch data structure&#34;)
            except DataError as e:
                self.logger.error(e)
        except DataError as e:
            self.logger.error(e)

        sql_check_unique = &#34;select * from branch where code = %(branch_code)s&#34;
        sql_country_exists = &#34;select id from country where code = %(country_code)s&#34;
        sql_sub_exists = &#34;select b.id from branch b join sport s on s.id = b.sport_id &#34; \
                         &#34;and s.code =  %(sport_code)s and b.code = %(branch_code)s&#34;

        sql_insert = &#34;insert into branch(code, title, is_combined, country_id) &#34; \
                     &#34;values (%(code)s, %(title)s, %(is_combined)s, %(country_id)s ) returning id&#34;
        sql_connect = &#34;insert into combi_branch(combi_branch_id, subbranch_id, coefficient) &#34; \
                      &#34;values (%(combi_branch_id)s, %(subbranch_id)s, %(coefficient)s )&#34;

        inserting_data = []

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:

                    cursor.execute(sql_check_unique, {&#34;branch_code&#34;: data[&#39;branchCode&#39;]})
                    tmp = cursor.fetchone()
                    if tmp is not None:  # branch code already exists
                        self._releaseConnection(dbConn)
                        raise DataError(&#34;branch with entered code already exists&#34;)

                    cursor.execute(sql_country_exists, {&#34;country_code&#34;: data[&#34;countryCode&#34;]})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        self._releaseConnection(dbConn)
                        raise DataError(&#34;country with entered code does not exist&#34;)
                    country_id = tmp[0]

                    for sub in data[&#34;subBranches&#34;]:
                        try:
                            cursor.execute(sql_sub_exists,
                                           {&#34;sport_code&#34;: sub[&#34;sportCode&#34;], &#34;branch_code&#34;: sub[&#34;branchCode&#34;]})
                        except KeyError:
                            self._releaseConnection(dbConn)
                            raise DataError(&#34;invalid subBranches data structure&#34;)
                        tmp = cursor.fetchone()
                        if tmp is None:
                            self._releaseConnection(dbConn)
                            raise DataError(&#34;subBranches does not exist&#34;)
                        else:
                            inserting_data.append((tmp[0], sub[&#34;coefficient&#34;]))

                    cursor.execute(sql_insert,
                                   {&#34;code&#34;: data[&#34;branchCode&#34;], &#34;title&#34;: data[&#34;branchTitle&#34;], &#34;is_combined&#34;: True,
                                    &#34;country_id&#34;: country_id})
                    tmp = cursor.fetchone()
                    newBranchId = tmp[0]

                    for item in inserting_data:
                        cursor.execute(sql_connect, {&#34;combi_branch_id&#34;: newBranchId, &#34;subbranch_id&#34;: item[0],
                                                     &#34;coefficient&#34;: item[1]})

                    dbConn.commit()

            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def addCountry(self, data: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34; Activating inactive or adding a new country to DB.

        Args:
            data (dict): dict with keys name, translation, code which describe country

        Returns:
            bool: true/false whether combi country was successfully added / activated
        &#34;&#34;&#34;

        if &#34;name&#34; not in data:
            raise DataError(&#34;country name missing in data&#34;)

        if &#34;translation&#34; not in data:
            raise DataError(&#34;translation to slovak missing in data&#34;)

        if &#34;code&#34; not in data:
            raise DataError(&#34;country code missing in data&#34;)

        sql_check = &#34;select name, is_active from country where code=%(code)s&#34;
        sql_activate = &#34;update country set is_active = true where code = %(code)s&#34;
        sql_add = &#34;insert into country(name, is_active, translation, code) &#34; \
                  &#34;values ( %(name)s, %(is_active)s, %(translation)s, %(code)s )&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:

                    cursor.execute(sql_check, {&#34;code&#34;: data[&#39;code&#39;]})
                    tmp = cursor.fetchone()
                    if tmp is None:  # adding completely new country

                        cursor.execute(sql_add,
                                       {&#34;name&#34;: data[&#34;name&#34;], &#34;is_active&#34;: True, &#34;translation&#34;: data[&#34;translation&#34;],
                                        &#34;code&#34;: data[&#34;code&#34;]})
                        dbConn.commit()

                    else:  # activating country

                        if tmp[1] is True or tmp[0] != data[&#34;name&#34;]:  # country already active
                            self._releaseConnection(dbConn)
                            raise DataError(
                                f&#34;country with entered code already exists - {tmp[0]}, please select another code&#34;)

                        cursor.execute(sql_activate, {&#34;code&#34;: data[&#34;code&#34;]})
                        dbConn.commit()

            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def updateSport(self, data: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34; Updating sport code or title or both.

        Args:
            data (dict): dict with keys oldCode, newCode newTitle which describe sport and changes

        Returns:
            bool: true/false whether sport was successfully updated
        &#34;&#34;&#34;

        if &#34;oldCode&#34; not in data:
            raise DataError(&#34;sport data do not contain old code&#34;)
        if &#34;newCode&#34; not in data:
            raise DataError(&#34;sport data do not contain new code&#34;)
        if &#34;newTitle&#34; not in data:
            raise DataError(&#34;sport data do not contain new title&#34;)

        sql_check = &#34;select id from sport where code = %(old_code)s&#34;
        sql = &#34;update sport set code=%(new_code)s, title= %(new_title)s where id= %(id)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_check, {&#34;old_code&#34;: data[&#39;oldCode&#39;]})
                    tmp = cursor.fetchone()
                    if tmp is None:  # sport doesnt exist
                        self._releaseConnection(dbConn)
                        raise DataError(&#34;unable to update sport, sport with entered code doesnt exist&#34;)
                    cursor.execute(sql, {&#34;new_code&#34;: data[&#39;newCode&#39;], &#34;new_title&#34;: data[&#39;newTitle&#39;], &#34;id&#34;: tmp[0]})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False


    def importFundingData(self, country_id: id, branch_id: id, amount: float, currency: str):
        &#34;&#34;&#34;Adds 1 fund into database.

                   Args:
                       country_id: id representation of country
                       branch_id: id representation of branch
                       amount: how much money was funded
                       currency: ISO 4217 of fund currency

                   Returns:
                       bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql_del = &#34;delete from funding where country_id=%(country_id)s and branch_id=%(branch_id)s&#34;

        sql = &#34;insert into funding(country_id, branch_id, absolute_funding, currency) &#34; \
              &#34;values (%(country_id)s, %(branch_id)s, %(amount)s, %(currency)s)&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_del, {&#34;country_id&#34;: country_id, &#34;branch_id&#34;: branch_id})
                    cursor.execute(sql, {&#34;country_id&#34;: country_id, &#34;branch_id&#34;: branch_id, &#34;amount&#34;: amount,
                                         &#34;currency&#34;: currency})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False


    def deleteBGS(self):
        &#34;&#34;&#34;deletes BGS table, restarts serial identity

                   Args:

                   Returns:
                       bool: true/false whether deleting was successfull
           &#34;&#34;&#34;
        sql = &#34;TRUNCATE BGS RESTART IDENTITY &#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importBGSdata(self, sport_id: id, value: int):
        &#34;&#34;&#34;add BGS record into database
                   Args:
                        sport_id: id representation of sport
                        value: int value of BGS
                   Returns:
                        bool: true/false whether import was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into BGS(sport_id, value) &#34; \
                &#34;values (%(sport_id)s, %(value)s)&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_id&#34;: sport_id,  &#34;value&#34;: value})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False



    def deleteSuccesTables(self):
        &#34;&#34;&#34;deletes all tables that are used with success data
                   Args:

                   Returns:
                        bool: true/false whether deleting was successfull
        &#34;&#34;&#34;
        sql = &#34;TRUNCATE  COUNTRY_BEST_ORDER, TOTAL_COUNTRY_POINTS,&#34; \
              &#34; MAX_POINTS_IN_SPORT, NUM_IN_SPORT, success RESTART IDENTITY &#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importSuccessdata(self, sport_id: id, country_id: id, points: float, orders: int):
        &#34;&#34;&#34;add success record into DB
                   Args:
                        sport_id: id representation of sport
                        country_id: id representation of country
                        points: float, how many points did country get in sport
                        orders: int, in which place did the country ended up
                   Returns:
                        bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into success(sport_id, country_id, points, orders) &#34; \
              &#34;values (%(sport_id)s, %(country_id)s, %(points)s, %(orders)s)&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_id&#34;: sport_id, &#34;country_id&#34;: country_id, &#34;points&#34;: points,
                                         &#34;orders&#34;: orders})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importNumberInSports(self, sport_id: id, num_countries: int):
        &#34;&#34;&#34;add how many sports were ranked in specific sport
                   Args:
                        sport_id: id represenation of sport,
                        num_countries: how many countries are in the success ranking
                   Returns:
                        bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into NUM_IN_SPORT(sport_id, num_countries) &#34; \
              &#34;values (%(sport_id)s, %(num_countries)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_id&#34;: sport_id, &#34;num_countries&#34;: num_countries})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importMaxPointsInSport(self, sport_id: id, points: float):
        &#34;&#34;&#34;add highest points in specific sport
                         Args:
                              sport_id: id represenation of sport,
                              points: maximum of the points in sport
                         Returns:
                              bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into MAX_POINTS_IN_SPORT(sport_id, points) &#34; \
              &#34;values (%(sport_id)s, %(points)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_id&#34;: sport_id, &#34;points&#34;: points})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importTotalCountryPoints(self, country_id: id, points: float):
        &#34;&#34;&#34;add sum of points above all sports for specific country
                         Args:
                              country_id: id represenation of country,
                              points: sum of points from all sports
                         Returns:
                              bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into TOTAL_COUNTRY_POINTS(country_id, points) &#34; \
              &#34;values (%(country_id)s, %(points)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_id&#34;: country_id, &#34;points&#34;: points})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importCountryBestOrder(self, country_id: id, best: int):
        &#34;&#34;&#34;add best placement of specific country
                         Args:
                              country_id: id represenation of country,
                              points: best placement of country
                         Returns:
                              bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into COUNTRY_BEST_ORDER(country_id, best) &#34; \
              &#34;values (%(country_id)s, %(best)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_id&#34;: country_id, &#34;best&#34;: best})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False


    def deleteInterconnectednessTables(self, type_id: id):
        &#34;&#34;&#34;deletes data from interconnectedness table, with specific type_id
                         Args:
                              type_id: type of interconnectedness ( 1 economic, 2 non-economic )

                         Returns:
                              bool: true/false whether deleting was successfull
        &#34;&#34;&#34;
        sql_del = &#34;DELETE FROM interconnectness WHERE type_id =%(type_id)s   &#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_del, {&#34;type_id&#34;: type_id})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importInterconnectednessData(self, type_id: id, country_one_id: id, country_two_id: id, value: float):
        &#34;&#34;&#34;imports interconnectedness record
                              Args:
                                   type_id: type of interconnectedness ( 1 economic, 2 non-economic )
                                   country_one_id: id representation of country
                                   country_two_id: id representation of country ( they can not match )
                                   value: value of interconnectedness between country1 and country2

                              Returns:
                                   bool: true/false whether deleting was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into interconnectness(type_id, country_one_id, country_two_id, value ) &#34; \
              &#34;values (%(type_id)s, %(country_one_id)s, %(country_two_id)s , %(value)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;type_id&#34;: type_id, &#34;country_one_id&#34;: country_one_id,
                                         &#34;country_two_id&#34;: country_two_id, &#34;value&#34;: value})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            #print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    # getters for DB mirroring in data computation modul

    def getBGS(self) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Get all records from table BGS.

        Returns:
            Dict[str, List[Dict[str, Any]]]: dict with one key BGS,
            which value is list of dicts with keys sport_id, value
        &#34;&#34;&#34;

        sql = &#34;select sport_id, value from BGS&#34;
        result = {&#34;BGS&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;BGS&#34;].append({&#34;sport_id&#34;: tmp[0], &#34;value&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            result = result[&#34;BGS&#34;]
            final_result = {}

            for record in result:
                final_result[record[&#34;sport_id&#34;]] = record[&#34;value&#34;]

            return final_result

    def getOrder(self) -&gt; Dict[int, Dict[int, int]]:
        &#34;&#34;&#34; Get order of each country in each sport from table success .

        Returns:
            Dict[int, Dict[int, int]]:  dict with keys = country ids, its value is dict
            with items sport id -&gt; order
        &#34;&#34;&#34;

        sql = &#34;select country_id, sport_id, orders from success&#34;
        result = {&#34;order&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, sport_id, order = tmp
                        result[&#34;order&#34;].append({&#34;country_id&#34;: country_id, &#34;sport_id&#34;: sport_id, &#34;order&#34;: order})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;order&#34;]:

                country_id, sport_id, order = record[&#34;country_id&#34;], record[&#34;sport_id&#34;], record[&#34;order&#34;]

                if record[&#34;country_id&#34;] not in final_result:
                    final_result[country_id] = {}

                final_result[country_id][sport_id] = order

            return final_result

    def getPoints(self) -&gt; Dict[id, Dict[id, float]]:
        &#34;&#34;&#34; Get points of each country in each sport from table success .

        Returns:
             Dict[id, Dict[id, float]]:  dict with keys = country ids, its value is dict
            with items sport id -&gt; points
        &#34;&#34;&#34;

        sql = &#34;select country_id, sport_id, points from success&#34;
        result = {&#34;points&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, sport_id, points = tmp
                        result[&#34;points&#34;].append({&#34;country_id&#34;: country_id, &#34;sport_id&#34;: sport_id, &#34;points&#34;: points})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;points&#34;]:

                country_id, sport_id, points = record[&#34;country_id&#34;], record[&#34;sport_id&#34;], record[&#34;points&#34;]

                if record[&#34;country_id&#34;] not in final_result:
                    final_result[country_id] = {}

                final_result[country_id][sport_id] = points

            return final_result

    def getMaxPoints(self) -&gt; Dict[id, float]:
        &#34;&#34;&#34; Get maximum points for each country in any sport from table MAX_POINTS_IN_SPORT.

        Returns:
            Dict[id,float]:  dict with keys = sport ids, its value is max points
        &#34;&#34;&#34;

        sql = &#34;select sport_id, points from MAX_POINTS_IN_SPORT&#34;
        result = {&#34;points&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        sport_id, points = tmp
                        result[&#34;points&#34;].append({&#34;sport_id&#34;: sport_id, &#34;points&#34;: points})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;points&#34;]:
                sport_id, points = record[&#34;sport_id&#34;], record[&#34;points&#34;]

                final_result[sport_id] = points

            return final_result

    def getNumCountriesInSport(self) -&gt; Dict[id, int]:
        &#34;&#34;&#34; Getter for table NUM_IN_SPORT which contains number of countries ranked in a sport.

        Returns:
            Dict[id, int]: dict sport id -&gt; number of countries
        &#34;&#34;&#34;

        sql = &#34;select sport_id, num_countries from NUM_IN_SPORT&#34;
        result = {&#34;num&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        sport_id, num = tmp
                        result[&#34;num&#34;].append({&#34;sport_id&#34;: sport_id, &#34;num&#34;: num})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;num&#34;]:
                sport_id, num = record[&#34;sport_id&#34;], record[&#34;num&#34;]

                final_result[sport_id] = num

            return final_result

    def getTotalCountryPoints(self) -&gt; Dict[id, float]:
        &#34;&#34;&#34; Get sum of points in all sport in a country.

        Returns:
            Dict[id, float]: dict of country id -&gt; sum of points
        &#34;&#34;&#34;
        sql = &#34;select country_id, points from TOTAL_COUNTRY_POINTS&#34;
        result = {&#34;sum&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, suma = tmp
                        result[&#34;sum&#34;].append({&#34;country_id&#34;: country_id, &#34;sum&#34;: suma})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;sum&#34;]:
                country_id, suma = record[&#34;country_id&#34;], record[&#34;sum&#34;]

                final_result[country_id] = suma

            return final_result

    def getMinOrder(self) -&gt; Dict[id, float]:
        &#34;&#34;&#34;Get minimum = best order of country in any sport.

        Returns:
            Dict[id, float]: dict of country id -&gt; order
        &#34;&#34;&#34;

        sql = &#34;select country_id, best from COUNTRY_BEST_ORDER &#34;
        result = {&#34;order&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, order = tmp
                        result[&#34;order&#34;].append({&#34;country_id&#34;: country_id, &#34;order&#34;: order})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;order&#34;]:
                country_id, order = record[&#34;country_id&#34;], record[&#34;order&#34;]

                final_result[country_id] = order

            return final_result

    def getEconIntercon(self) -&gt; Dict[id, Dict[id, float]]:
        &#34;&#34;&#34; Returns all economic interconnectness records from table interconnectness.

        Returns:
            Dict[id, Dict[id, float]]: dict of country id -&gt; dict of country id -&gt; econ interconnectness
        &#34;&#34;&#34;
        sql = &#34;select country_one_id, country_two_id, value from interconnectness where type_id = 1&#34;
        result = {&#34;inter&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_one_id, country_two_id, value = tmp
                        result[&#34;inter&#34;].append(
                            {&#34;country_one_id&#34;: country_one_id, &#34;country_two_id&#34;: country_two_id, &#34;value&#34;: value})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;inter&#34;]:
                country_one_id, country_two_id, value = record[&#34;country_one_id&#34;], record[&#34;country_two_id&#34;], record[
                    &#34;value&#34;]

                if country_one_id not in final_result:
                    final_result[country_one_id] = {}

                final_result[country_one_id][country_two_id] = value

            return final_result

    def getNonEconIntercon(self) -&gt; Dict[id, Dict[id, float]]:
        &#34;&#34;&#34; Returns all non economic interconnectness records from table interconnectness.

        Returns:
            Dict[id, Dict[id, float]]: dict of country id -&gt; dict of country id -&gt; non econ interconnectness
        &#34;&#34;&#34;
        sql = &#34;select country_one_id, country_two_id, value from interconnectness where type_id = 2&#34;
        result = {&#34;inter&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_one_id, country_two_id, value = tmp
                        result[&#34;inter&#34;].append(
                            {&#34;country_one_id&#34;: country_one_id, &#34;country_two_id&#34;: country_two_id, &#34;value&#34;: value})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;inter&#34;]:
                country_one_id, country_two_id, value = record[&#34;country_one_id&#34;], record[&#34;country_two_id&#34;], record[
                    &#34;value&#34;]

                if country_one_id not in final_result:
                    final_result[country_one_id] = {}

                final_result[country_one_id][country_two_id] = value

            return final_result

    def getNonCombiBranchFunding(self) -&gt; Dict[id, Dict[id, Dict[id, float]]]:
        &#34;&#34;&#34; Get all funding records for NONcombi branches from table funding.

        Returns:
            Dict[id, Dict[id, Dict[id, float]]]: dict of country id -&gt; dict of sport id -&gt;
            dict of branch id -&gt; total non combi branch funding
        &#34;&#34;&#34;
        sql = &#34;select f.country_id, sport_id, branch_id, sum(absolute_funding)  from funding f join branch b  &#34; \
              &#34;on b.id = f.branch_id  and is_combined = false group by f.country_id, sport_id, branch_id&#34;
        result = {&#34;funding&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, sport_id, branch_id, suma = tmp
                        result[&#34;funding&#34;].append(
                            {&#34;country_id&#34;: country_id, &#34;sport_id&#34;: sport_id, &#34;branch_id&#34;: branch_id, &#34;sum&#34;: suma})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;funding&#34;]:
                country_id, sport_id, branch_id, suma = record[&#34;country_id&#34;], record[&#34;sport_id&#34;], record[&#34;branch_id&#34;], \
                                                        record[&#34;sum&#34;]

                if country_id not in final_result:
                    final_result[country_id] = {}

                if sport_id not in final_result[country_id]:
                    final_result[country_id][sport_id] = {}

                final_result[country_id][sport_id][branch_id] = suma

            return final_result

    def getActiveCountryIds(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34; Returns active country data.

        Returns:
            List[Dict[str, Any]]: list of dicts, each dict contain keyd id, name = description of country.
        &#34;&#34;&#34;
        sql = &#34;select id, name from country where is_active = true&#34;
        result = {&#34;countries&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;countries&#34;].append({&#34;id&#34;: tmp[0], &#34;name&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;countries&#34;]


    def getActiveCountryTranslations(self) -&gt; list:
        &#34;&#34;&#34; Returns active country data with translations.

              Returns:
                  List[Dict[str, Any]]: list of dicts, each dict contain keyd id, translation = translation of country
              &#34;&#34;&#34;
        sql = &#34;select id, translation from country where is_active = true&#34;
        result = {&#34;countries&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;countries&#34;].append({&#34;id&#34;: tmp[0], &#34;translation&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;countries&#34;]

    def getSportIds(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34; Returns sports data from table sport.

        Returns:
            List[Dict[str, Any]]: list of dicts, each dict contain keys id, title = description of sport.
        &#34;&#34;&#34;
        sql = &#34;select id, title from sport&#34;
        result = {&#34;sports&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;sports&#34;].append({&#34;id&#34;: tmp[0], &#34;title&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;sports&#34;]

    def getCombiFunding(self) -&gt; Dict[id, Dict[id, Dict[id, float]]]:

        &#34;&#34;&#34; Get all funding records for combi branches from table funding.

        Returns:
            Dict[id, Dict[id, Dict[id, float]]]: dict of country id -&gt; subbranch id -&gt; combi branch id -&gt; funding
        &#34;&#34;&#34;

        sql = &#34;select b.country_id,  cb.subbranch_id, cb.combi_branch_id, absolute_funding * coefficient as fund &#34; \
              &#34;from branch b join combi_branch cb on b.id = cb.combi_branch_id &#34; \
              &#34;join funding f on f.country_id = b.country_id and f.branch_id = cb.combi_branch_id&#34;

        result = {&#34;funding&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;funding&#34;].append(
                            {&#34;country_id&#34;: tmp[0], &#34;subbranch_id&#34;: tmp[1], &#34;combi_branch_id&#34;: tmp[2], &#34;fund&#34;: tmp[3]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            final_result = {}

            for record in result[&#34;funding&#34;]:

                country_id, subbranch_id, combi_branch_id, fund = record[&#34;country_id&#34;], record[&#34;subbranch_id&#34;], record[
                    &#34;combi_branch_id&#34;], record[&#34;fund&#34;]

                if country_id not in final_result:
                    final_result[country_id] = {}

                if subbranch_id not in final_result[country_id]:
                    final_result[country_id][subbranch_id] = {}

                if combi_branch_id in final_result[country_id][subbranch_id]:
                    final_result[country_id][subbranch_id][combi_branch_id] += fund
                else:
                    final_result[country_id][subbranch_id][combi_branch_id] = fund

            return final_result

    def getNonCombiBranchIds(self) -&gt; List[Dict[str, id]]:

        &#34;&#34;&#34; Returns all ids of non combi branches in table branch.

        Returns:
            Dict[str, id]: list of dicts with key &#39;id&#39; and value combi branch id
        &#34;&#34;&#34;

        sql = &#34;select id from branch where is_combined = false&#34;
        result = {&#34;branches&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;branches&#34;].append({&#34;id&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;branches&#34;]

    def getTotalBranchFunding(self) -&gt; Dict[id, Dict[id, float]]:
        &#34;&#34;&#34;Returns total branch fnding = sum of direct funding and funding from combi branches.

        Returns:
            Dict[id, Dict[id, float]]: dict of country id -&gt; dict of branch id -&gt; total funding
        &#34;&#34;&#34;

        sql = &#34;&#34;&#34;select country_id, branch_id, sum(absolute_funding) from

            ((
                select f.country_id, branch_id, absolute_funding
                from funding f join branch b  
                on b.id = f.branch_id  and is_combined = false  
            )
            union
            (
                select b.country_id, cb.subbranch_id as branch_id, absolute_funding * coefficient as absolute_funding 
                from branch b join combi_branch cb on b.id = cb.combi_branch_id
                join funding f on f.country_id = b.country_id and f.branch_id = cb.combi_branch_id
                
            )) as x
            
            group by country_id, branch_id
            order by country_id, branch_id
            &#34;&#34;&#34;
        result = {&#34;funding&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;funding&#34;].append(
                            {&#34;country_id&#34;: tmp[0], &#34;branch_id&#34;: tmp[1], &#34;absolute_funding&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            final_result = {}

            for record in result[&#34;funding&#34;]:
                country_id, branch_id, absolute_funding = record[&#34;country_id&#34;], record[&#34;branch_id&#34;], record[
                    &#34;absolute_funding&#34;]

                if country_id not in final_result:
                    final_result[country_id] = {}

                final_result[country_id][branch_id] = absolute_funding

            return final_result

    def getNonCombiWithSportBranchIds(self) -&gt; Dict[id, List[id]]:
        &#34;&#34;&#34; Get non combi branch ids with sport it belongs to.

        Returns:
            Dict[id, List[id]]: dict of sport id -&gt; list of branch ids in this sport
        &#34;&#34;&#34;
        sql = &#34;select id, sport_id from branch where is_combined = false&#34;
        result = {&#34;branches&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;branches&#34;].append({&#34;id&#34;: tmp[0], &#34;sport_id&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            final_result = {}
            for record in result[&#34;branches&#34;]:
                sport_id, id = record[&#34;sport_id&#34;], record[&#34;id&#34;]
                if sport_id not in final_result:
                    final_result[sport_id] = []
                final_result[sport_id].append(id)
            return final_result

    def getAllSportInfo(self) -&gt; Dict[Any, Tuple[Any, Any]]:
        &#34;&#34;&#34; Get records from table sport.

        Returns:
            Dict[Any, Tuple[Any, Any]]: dict of sport id -&gt; (sport code, sport title)
        &#34;&#34;&#34;
        sql = &#34;select id, code, title from sport&#34;
        result = {&#34;sports&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;sports&#34;].append({&#34;id&#34;: tmp[0], &#34;code&#34;: tmp[1], &#34;title&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            final_result = {}
            for record in result[&#34;sports&#34;]:
                id, code, title = record[&#34;id&#34;], record[&#34;code&#34;], record[&#34;title&#34;]
                final_result[id] = (code, title)
            return final_result

    def checkCodeTitle(self, sport_code: int, branch_code: int, sport_title: str, branch_title: str) -&gt; bool:
        &#34;&#34;&#34; Check if branch and sport with sport code and branch code and titles exist and belongs together.

        Args:
            sport_code (int): selected sport code
            branch_code (int): selected branch code
            sport_title (str): selected sport title
            branch_title (str): selected branch title

        Returns:
            bool: true/false whether branch belongs to sport
        &#34;&#34;&#34;
        sql = &#34;select * from sport s join branch b on s.id = b.sport_id and s.code = %(sport_code)s &#34; \
              &#34;and b.code = %(branch_code)s and s.title = %(sport_title)s and b.title = %(branch_title)s &#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql,
                                   {&#34;sport_code&#34;: sport_code, &#34;branch_code&#34;: branch_code, &#34;sport_title&#34;: sport_title,
                                    &#34;branch_title&#34;: branch_title})
                    tmp = cursor.fetchone()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return tmp is not None
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def findSportByCode(self, sport_code: int) -&gt; str:
        &#34;&#34;&#34;Returns title of sport by entered code.

        Args:
            sport_code (int): selected sport code

        Returns:
            str: sport title
        &#34;&#34;&#34;

        sql = &#34;select title from sport where code = %(sport_code)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_code&#34;: sport_code})
                    tmp = cursor.fetchone()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return tmp[0] if tmp is not None else None
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return &#34;&#34;

    def findBranchByCode(self, sport_code: int, branch_code: int) -&gt; str:
        &#34;&#34;&#34;Returns branch title of branch defined by entered sport and branch code.

        Args:
            sport_code (int): selected sport code
            branch_code (int): selected branch code

        Returns:
            str: branch title
        &#34;&#34;&#34;

        sql = &#34;select b.title from branch b join sport s on s.id = b.sport_id &#34; \
              &#34;and s.code = %(sport_code)s and b.code = %(branch_code)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_code&#34;: sport_code, &#34;branch_code&#34;: branch_code})
                    tmp = cursor.fetchone()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return tmp[0] if tmp is not None else None
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return &#34;&#34;

    def getSportBranches(self, sport_code: int) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Returns all branches which belongs to entered sport.

        Args:
            sport_code (int): selected sport code

        Returns:
            List[Dict[str, Any]]: list of dicts , each dict contains keys code, title.
        &#34;&#34;&#34;

        sql = &#34;select b.code, b.title from branch b join sport s &#34; \
              &#34;on b.sport_id = s.id and s.code = %(code)s&#34;
        result = {&#34;branches&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;code&#34;: sport_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;branches&#34;].append({&#34;code&#34;: tmp[0], &#34;title&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)

        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)

        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;branches&#34;]

    def showCombiBranches(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Returns data about combi branches from table combi_branch.

        Returns:
            List[Dict[str, Any]]: list of dicts , each dict contains keys countryCode, countryName,
            combiCode, combiTitle, subCode, subTitle, coefficient
        &#34;&#34;&#34;

        sql = &#34;select c.code, c.name, b.code, b.title, b2.code, b2.title, coefficient &#34; \
              &#34;from combi_branch cb join branch b on combi_branch_id = b.id &#34; \
              &#34;join branch b2 on subbranch_id = b2.id &#34; \
              &#34;join country c on b.country_id = c.id&#34;
        results = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        results.append(
                            {&#34;countryCode&#34;: tmp[0], &#34;countryName&#34;: tmp[1], &#34;combiCode&#34;: tmp[2], &#34;combiTitle&#34;: tmp[3],
                             &#34;subCode&#34;: tmp[4], &#34;subTitle&#34;: tmp[5], &#34;coefficient&#34;: tmp[6]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return results

    def checkCombi(self, branch_code: int, country_code: str) -&gt; Tuple[int, str]:
        &#34;&#34;&#34; Check existance of combi branch. If exists, returns code, title else -1 and empty.

        Args:
            branch_code ([type]): selected branch code
            country_code ([type]): selected country code

        Returns:
             Tuple[int, str]: (branch code, country code)
        &#34;&#34;&#34;

        sql = &#34;select b.code, b.title from branch b join country c &#34; \
              &#34;on c.id = b.country_id and c.code = %(country_code)s and is_combined and b.code = %(branch_code)s &#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;branch_code&#34;: branch_code, &#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return -1, &#34;&#34;
                    else:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return tmp[0], tmp[1]

        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def suggestNewSportCode(self) -&gt; int:
        &#34;&#34;&#34; Returns suggestion for sport code.

        Returns:
            int: suggestion for sport code
        &#34;&#34;&#34;

        sql = &#34;select max(code)+1 from sport&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0] if tmp[0] is not None else 1
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def countryCodeToID(self, country_code: str) -&gt; id:
        &#34;&#34;&#34; Convert country code to country id.

        Args:
            country_code (str):  selected country code

        Returns:
            id: id of the country with selected code, if not exist then -1
        &#34;&#34;&#34;

        sql = &#34;select id from country where code=%(country_code)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return -1
                    else:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return tmp[0]

        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def suggestNewBranchCode(self, sport_code: int) -&gt; int:
        &#34;&#34;&#34; Returns suggestion for branch code in entered sport.

        Args:
            sport_code (int): selected sport code

        Returns:
            int: suggestion for branch code under selected sport
        &#34;&#34;&#34;

        sql = &#34;select max(b.code)+1 from branch b &#34; \
              &#34;join sport s on s.id = b.sport_id and s.code = %(sport_code)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_code&#34;: sport_code})
                    tmp = cursor.fetchone()
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0] if tmp[0] is not None else 1
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def branchCodeToId(self, sport_code: int, branch_code: int) -&gt; id:
        &#34;&#34;&#34; Convert branch code to id.
            Branch is defined by branch code and sport code it belongs to.


        Args:
            sport_code (int): selected sport code
            branch_code (int): selected branch code

        Returns:
            id: return branch id
        &#34;&#34;&#34;

        sql = &#34;select b.id from branch b join sport s on s.id = b.sport_id and &#34; \
              &#34; b.code = %(branch_code)s and s.code =  %(sport_code)s &#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;branch_code&#34;: branch_code, &#34;sport_code&#34;: sport_code})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return -1
                    else:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return tmp[0]
        except psycopg2.DatabaseError as error:
            # print(error)
            #print(dbConn)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def suggestNewCombiBranchCode(self) -&gt; int:
        &#34;&#34;&#34; Returns suggestion for combi branch code.

        Returns:
            int: suggestion for new combi branch code
        &#34;&#34;&#34;
        sql = &#34;select max(b.code)+1 from branch b where is_combined&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0] if tmp[0] is not None else 10000
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def getSportsWithExisitingBranch(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34; Returns sports from table sport which have at least one branch.
            
        Returns:
            List[Dict[str, Any]]: list of dicts , each dict contains keys title, code.

        &#34;&#34;&#34;
        sql = &#34;select s.code, s.title from sport s &#34; \
              &#34; where exists(select * from branch where sport_id = s.id) &#34;

        sports = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        sports.append({&#34;title&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return sports

    def combiBranchCodeToId(self, branch_code: int) -&gt; id:
        &#34;&#34;&#34; Convert combi branch code to id.

        Args:
            branch_code (int): selected branch code

        Returns:
            id: return id of combi branch
        &#34;&#34;&#34;

        sql = &#34;select b.id from branch b where is_combined and code = %(code)s&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;code&#34;: branch_code})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return -1
                    else:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return tmp[0]
        except psycopg2.DatabaseError as error:
            # print(error)
            #print(dbConn)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def getInterconnTypes(self) -&gt; Dict[str, list]:
        &#34;&#34;&#34; Returns interconnectness types from table interconnectness_type.

        Returns:
            Dict[str, list]: list of dicts , each dict contains keys title, code.
        &#34;&#34;&#34;

        sql = &#34;select code, title from interconnectness_type&#34;
        results = {&#34;interconnectnesstype&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        results[&#34;interconnectnesstype&#34;].append({&#34;code&#34;: tmp[0], &#34;title&#34;: tmp[1]})
                        tmp = cursor.fetchone()
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return results</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="__init__.DataError"><code class="flex name class">
<span>class <span class="ident">DataError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="__init__.Database"><code class="flex name class">
<span>class <span class="ident">Database</span></span>
<span>(</span><span>dbPool:psycopg2.pool.ThreadedConnectionPool)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize DB pool and DB logger.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Database:

    @staticmethod
    def createDatabaseBackup():
        &#34;&#34;&#34; Create (save) backup of current version of the database.
            Saved file names are in format sport_db_backup{timestamp_in_ms}.bak
        &#34;&#34;&#34;
        DB_HOST = env.get(&#34;DB_HOST&#34;)
        DB_NAME = env.get(&#34;DB_NAME&#34;)
        DB_USER = env.get(&#34;DB_USER&#34;)
        DB_PASS = env.get(&#34;DB_PASS&#34;)
        system(f&#39;pg_dump &#34;host={DB_HOST} port=5432 dbname={DB_NAME} user={DB_USER} password={DB_PASS}&#34; &gt; &#39;
               f&#39;db/backups/sport_db_backup{int(round(time() * 1000))}.bak&#39;)

    def __init__(self, dbPool: psycopg2.pool.ThreadedConnectionPool):
        &#34;&#34;&#34; Initialize DB pool and DB logger. &#34;&#34;&#34;

        self.dbPool = dbPool

        LOG_PATH = &#34;logs&#34;
        LOG_FILE = &#34;db&#34;
        name = join(LOG_PATH, LOG_FILE)

        formatter = logging.Formatter(&#39;%(asctime)s %(levelname)-8s %(message)s&#39;)

        handler = logging.FileHandler(name + &#34;.log&#34;, mode=&#39;a&#39;)
        handler.setFormatter(formatter)

        logger = logging.getLogger(name)
        logger.setLevel(logging.DEBUG)
        logger.addHandler(handler)

        self.logger = logger

    def _getConnection(self) -&gt; psycopg2.extensions.connection:
        &#34;&#34;&#34; Establish and return connection from DB pool.

            Returns:
                psycopg2.extensions.connection: DB connection from DB pool
        &#34;&#34;&#34;
        dbConn = self.dbPool.getconn()
        return dbConn

    def _releaseConnection(self, dbConnection: psycopg2.extensions.connection):
        &#34;&#34;&#34; Releases connection.

        Args:
            dbConnection (psycopg2.extensions.connection): database connection
        &#34;&#34;&#34;

        self.dbPool.putconn(dbConnection)

    def getSecretary(self, email: str) -&gt; Union[None, dict]:
        &#34;&#34;&#34; Use in secretary login process.

        Args:
            email (str): entered admin email

        Returns:
            Union[None, dict]: dict of record in DB which email is same as entered email
        &#34;&#34;&#34;

        sql = &#34;select * from users where email=%s and type=&#39;secretary&#39;&#34;
        result = None
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, (email,))
                    result = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getAdmin(self, email: str) -&gt; Union[None, dict]:
        &#34;&#34;&#34; Use in admin login process.

        Args:
            email (str): entered admin email

        Returns:
            Union[None, dict]: dict of record in DB which email is same as entered email
        &#34;&#34;&#34;

        sql = &#34;select * from users where email=%s and type=&#39;admin&#39;&#34;
        result = None
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, (email,))
                    result = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getAllCountries(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;  Returns all active countries from table countries.

        Returns:
            List[Dict[str, Any]]: list of dicts , each dict contains keys name, code
        &#34;&#34;&#34;

        sql = &#34;select code, name from country where is_active = true&#34;
        countries = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        countries.append({&#34;name&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return countries

    def getAllSports(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34; Returns all sports from table sports.

        Returns:
            List[Dict[str, Any]]:  list of dicts , each dict contains keys title, code
        &#34;&#34;&#34;

        sql = &#34;select code, title from sport&#34;
        sports = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        sports.append({&#34;title&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return sports

    def getInactiveCountries(self) -&gt; Dict[str, List[Dict[str, Any]]]:

        &#34;&#34;&#34; Get all inactive countries from table countries.

            Returns:
                dict:  dict with one key = countries, its value is
                list of dicts , each dict contains keys name, code
        &#34;&#34;&#34;

        sql = &#34;select code, name from country where is_active = false&#34;
        result = {&#34;countries&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;countries&#34;].append({&#34;name&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getBranchesWithSports(self) -&gt; List[Dict[str, Any]]:

        &#34;&#34;&#34;  Returns non combi branches from table branch with sport they belong to.

        Returns:
            list:  list of dicts , each dict contains keys sportCode, sportTitle, branchCode, branchTitle.
        &#34;&#34;&#34;

        sql = &#34;select s.code, s.title, b.code, b.title from sport s join branch b on b.sport_id = s.id&#34;
        results = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        results.append(
                            {&#34;sportCode&#34;: tmp[0], &#34;sportTitle&#34;: tmp[1], &#34;branchCode&#34;: tmp[2], &#34;branchTitle&#34;: tmp[3]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return results

    def getFundingData(self, country_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Returns funding data from table funding for selected country.

        Args:
            country_code (str): selected country code

        Returns: Dict[str, List[Dict[str, Any]]]: list of dicts , each dict contains keys branch_id,
        absolute_funding, currency.

        &#34;&#34;&#34;

        sql = &#34;select b.title, f.absolute_funding, f.currency from funding f cross join country c &#34; \
              &#34;join branch b on c.code = %(country_code)s and f.country_id = c.id and b.id = f.branch_id&#34;
        result = {&#34;funding&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;funding&#34;].append({&#34;branch_id&#34;: tmp[0], &#34;absolute_funding&#34;: tmp[1], &#34;currency&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getFundingDistinctCurrencies(self) -&gt; List[str]:
        &#34;&#34;&#34;
            Get list of currencies used in funding data in table funding.

            Returns:
                list: list of strings = currency names.
        &#34;&#34;&#34;

        sql = &#34; select distinct currency from funding where currency != &#39;&#39; &#34;
        results = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
                    cursor.execute(sql)
                    results = cursor.fetchall()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return results

    def getSuccessBySport(self, sport_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Return success records from table success for selected sport.

        Args:
            sport_code (str): code of selected sport

        Returns:
            dict: dict with one key = success, its value is list of dicts, each dict contains
            keys country_name, points, order
        &#34;&#34;&#34;

        sql = &#34;select c.name, suc.points, suc.orders from success suc cross join sport sp &#34; \
              &#34;join country c on suc.sport_id = sp.id and sp.code = %(sport_code)s &#34; \
              &#34;and suc.country_id = c.id order by suc.orders;&#34;
        result = {&#34;success&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_code&#34;: sport_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;success&#34;].append({&#34;country_name&#34;: tmp[0], &#34;points&#34;: tmp[1], &#34;order&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getSuccessByCountry(self, country_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Return success records from table success for selected country.

        Args:
            country_code (str): code of selected country

        Returns:
            dict: dict with one key = success, its value is list of dicts, each dict contains
            keys sport_name, points, order
        &#34;&#34;&#34;

        sql = &#34;select sp.title, suc.points, suc.orders from success suc cross join sport sp &#34; \
              &#34;join country c on suc.sport_id = sp.id and c.code = %(country_code)s &#34; \
              &#34;and suc.country_id = c.id order by suc.orders;&#34;
        result = {&#34;success&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;success&#34;].append({&#34;sport_name&#34;: tmp[0], &#34;points&#34;: tmp[1], &#34;order&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    def getInterconnectnessData(self, type_id: int, country_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Returns data from table interconnectness for specified country.

                Args:
                    type_id (int): type of intesconnectness, 1 = economic, 2 = non economic
                    country_code (str): code of country

                Returns:
                    dict: dict with one key interconnectness which value is list of dicts with keyscountry, value, type
        &#34;&#34;&#34;

        sql = &#34;select c2.code, c2.name, i.value, it.title  from interconnectness i join country c1 &#34; \
              &#34;on country_one_id = c1.id join country c2 on country_two_id = c2.id join interconnectness_type it &#34; \
              &#34;on i.type_id = it.id where i.type_id = %(type_id)s and c1.code = %(country_code)s &#34;
        result = {&#34;interconnectness&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;type_id&#34;: type_id, &#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;interconnectness&#34;].append(
                            {&#34;code&#34;: tmp[0], &#34;country&#34;: tmp[1], &#34;value&#34;: tmp[2], &#34;type&#34;: tmp[3]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result

    # inputs to DB

    def addSport(self, code: str, title: str) -&gt; bool:
        &#34;&#34;&#34; Adding a new sport to DB.

            Args:
                code (str): code of new sport
                title (str): title of new sport

            Returns:
                bool: true/false whether sport was successfully added
        &#34;&#34;&#34;
        sql_check = &#34;select * from sport where code = %(code)s&#34;
        sql = &#34;insert into sport(code, title) values (%(code)s, %(title)s);&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_check, {&#34;code&#34;: code})
                    tmp = cursor.fetchone()
                    if tmp is not None:  # sport code already exists
                        self._releaseConnection(dbConn)
                        raise DataError(
                            &#34;unable to insert, sport with entered code already exists, please select another code&#34;)
                    cursor.execute(sql, {&#34;code&#34;: code, &#34;title&#34;: title})
                    dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def addBranch(self, data: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34; Adding a new branch to DB.

            Args:
                data (dict): dict with keys sportCode, branchCode, branchTitle to describe new branch

            Returns:
                bool: true/false whether branch was successfully added
        &#34;&#34;&#34;
        if &#34;sportCode&#34; not in data:
            raise DataError(&#34;sport code missing in data&#34;)

        if &#34;branchCode&#34; not in data:
            raise DataError(&#34;branch code not in data&#34;)

        if &#34;branchTitle&#34; not in data:
            raise DataError(&#34;branch title not in data&#34;)

        sql_sport = &#34;select id from sport where code = %(sport_code)s&#34;
        sql_check = &#34;select s.id, b.title from sport s join branch b on s.id = b.sport_id &#34; \
                    &#34;and s.code = %(sport_code)s and b.code = %(branch_code)s&#34;
        sql = &#34;insert into branch(code, title, is_combined, sport_id) &#34; \
              &#34;values ( %(code)s, %(title)s, %(is_combined)s, %(sport_id)s )&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_sport, {&#34;sport_code&#34;: data[&#34;sportCode&#34;]})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        self._releaseConnection(dbConn)

                        raise DataError(
                            f&#34;unable to insert, sport with entered code doesnt exist, please select another code&#34;)
                    sport_id = tmp[0]

                    cursor.execute(sql_check, {&#34;sport_code&#34;: data[&#39;sportCode&#39;], &#34;branch_code&#34;: data[&#39;branchCode&#39;]})
                    tmp = cursor.fetchone()
                    if tmp is not None:  # branch code already exists
                        self._releaseConnection(dbConn)
                        raise DataError(
                            f&#34;unable to insert, branch with entered code already exists - {tmp[1]}, &#34;
                            f&#34;please select another code&#34;)

                    cursor.execute(sql,
                                   {&#34;code&#34;: data[&#39;branchCode&#39;], &#34;title&#34;: data[&#39;branchTitle&#39;], &#34;is_combined&#34;: &#39;false&#39;,
                                    &#34;sport_id&#34;: sport_id})
                    dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def addCombiBranch(self, data: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34; Adding a new combi branch to DB.

        Args:
            data (dict): dict with items branchCode -&gt; int , branchTitle -&gt; str, countryCode -&gt; str, subBranches -&gt; list
            subbranches value is list of dicts with keys sportCode, branchCode, coefficient which describe subbranch


        Returns:
            bool: true/false whether combi branch was successfully added

        &#34;&#34;&#34;

        if &#34;branchCode&#34; not in data:
            raise DataError(&#34;branch code missing in data&#34;)

        if &#34;branchTitle&#34; not in data:
            raise DataError(&#34;branch title missing in data&#34;)

        if &#34;countryCode&#34; not in data:
            raise DataError(&#34;country code missing in data&#34;)

        if &#34;subBranches&#34; not in data:
            raise DataError(&#34;subBranches data missing&#34;)

        if not isinstance(data[&#34;subBranches&#34;], list):
            raise DataError(&#34;invalid subBranches data structure&#34;)

        suma = 0
        try:
            for i in data[&#34;subBranches&#34;]:
                suma += i[&#34;coefficient&#34;]
            if suma != 1:
                raise DataError(&#34;coefficients sum is not 1&#34;)
        except KeyError:
            try:
                raise DataError(&#34;invalid subbranch data structure&#34;)
            except DataError as e:
                self.logger.error(e)
        except DataError as e:
            self.logger.error(e)

        sql_check_unique = &#34;select * from branch where code = %(branch_code)s&#34;
        sql_country_exists = &#34;select id from country where code = %(country_code)s&#34;
        sql_sub_exists = &#34;select b.id from branch b join sport s on s.id = b.sport_id &#34; \
                         &#34;and s.code =  %(sport_code)s and b.code = %(branch_code)s&#34;

        sql_insert = &#34;insert into branch(code, title, is_combined, country_id) &#34; \
                     &#34;values (%(code)s, %(title)s, %(is_combined)s, %(country_id)s ) returning id&#34;
        sql_connect = &#34;insert into combi_branch(combi_branch_id, subbranch_id, coefficient) &#34; \
                      &#34;values (%(combi_branch_id)s, %(subbranch_id)s, %(coefficient)s )&#34;

        inserting_data = []

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:

                    cursor.execute(sql_check_unique, {&#34;branch_code&#34;: data[&#39;branchCode&#39;]})
                    tmp = cursor.fetchone()
                    if tmp is not None:  # branch code already exists
                        self._releaseConnection(dbConn)
                        raise DataError(&#34;branch with entered code already exists&#34;)

                    cursor.execute(sql_country_exists, {&#34;country_code&#34;: data[&#34;countryCode&#34;]})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        self._releaseConnection(dbConn)
                        raise DataError(&#34;country with entered code does not exist&#34;)
                    country_id = tmp[0]

                    for sub in data[&#34;subBranches&#34;]:
                        try:
                            cursor.execute(sql_sub_exists,
                                           {&#34;sport_code&#34;: sub[&#34;sportCode&#34;], &#34;branch_code&#34;: sub[&#34;branchCode&#34;]})
                        except KeyError:
                            self._releaseConnection(dbConn)
                            raise DataError(&#34;invalid subBranches data structure&#34;)
                        tmp = cursor.fetchone()
                        if tmp is None:
                            self._releaseConnection(dbConn)
                            raise DataError(&#34;subBranches does not exist&#34;)
                        else:
                            inserting_data.append((tmp[0], sub[&#34;coefficient&#34;]))

                    cursor.execute(sql_insert,
                                   {&#34;code&#34;: data[&#34;branchCode&#34;], &#34;title&#34;: data[&#34;branchTitle&#34;], &#34;is_combined&#34;: True,
                                    &#34;country_id&#34;: country_id})
                    tmp = cursor.fetchone()
                    newBranchId = tmp[0]

                    for item in inserting_data:
                        cursor.execute(sql_connect, {&#34;combi_branch_id&#34;: newBranchId, &#34;subbranch_id&#34;: item[0],
                                                     &#34;coefficient&#34;: item[1]})

                    dbConn.commit()

            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def addCountry(self, data: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34; Activating inactive or adding a new country to DB.

        Args:
            data (dict): dict with keys name, translation, code which describe country

        Returns:
            bool: true/false whether combi country was successfully added / activated
        &#34;&#34;&#34;

        if &#34;name&#34; not in data:
            raise DataError(&#34;country name missing in data&#34;)

        if &#34;translation&#34; not in data:
            raise DataError(&#34;translation to slovak missing in data&#34;)

        if &#34;code&#34; not in data:
            raise DataError(&#34;country code missing in data&#34;)

        sql_check = &#34;select name, is_active from country where code=%(code)s&#34;
        sql_activate = &#34;update country set is_active = true where code = %(code)s&#34;
        sql_add = &#34;insert into country(name, is_active, translation, code) &#34; \
                  &#34;values ( %(name)s, %(is_active)s, %(translation)s, %(code)s )&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:

                    cursor.execute(sql_check, {&#34;code&#34;: data[&#39;code&#39;]})
                    tmp = cursor.fetchone()
                    if tmp is None:  # adding completely new country

                        cursor.execute(sql_add,
                                       {&#34;name&#34;: data[&#34;name&#34;], &#34;is_active&#34;: True, &#34;translation&#34;: data[&#34;translation&#34;],
                                        &#34;code&#34;: data[&#34;code&#34;]})
                        dbConn.commit()

                    else:  # activating country

                        if tmp[1] is True or tmp[0] != data[&#34;name&#34;]:  # country already active
                            self._releaseConnection(dbConn)
                            raise DataError(
                                f&#34;country with entered code already exists - {tmp[0]}, please select another code&#34;)

                        cursor.execute(sql_activate, {&#34;code&#34;: data[&#34;code&#34;]})
                        dbConn.commit()

            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def updateSport(self, data: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34; Updating sport code or title or both.

        Args:
            data (dict): dict with keys oldCode, newCode newTitle which describe sport and changes

        Returns:
            bool: true/false whether sport was successfully updated
        &#34;&#34;&#34;

        if &#34;oldCode&#34; not in data:
            raise DataError(&#34;sport data do not contain old code&#34;)
        if &#34;newCode&#34; not in data:
            raise DataError(&#34;sport data do not contain new code&#34;)
        if &#34;newTitle&#34; not in data:
            raise DataError(&#34;sport data do not contain new title&#34;)

        sql_check = &#34;select id from sport where code = %(old_code)s&#34;
        sql = &#34;update sport set code=%(new_code)s, title= %(new_title)s where id= %(id)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_check, {&#34;old_code&#34;: data[&#39;oldCode&#39;]})
                    tmp = cursor.fetchone()
                    if tmp is None:  # sport doesnt exist
                        self._releaseConnection(dbConn)
                        raise DataError(&#34;unable to update sport, sport with entered code doesnt exist&#34;)
                    cursor.execute(sql, {&#34;new_code&#34;: data[&#39;newCode&#39;], &#34;new_title&#34;: data[&#39;newTitle&#39;], &#34;id&#34;: tmp[0]})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except (psycopg2.DatabaseError, DataError) as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False


    def importFundingData(self, country_id: id, branch_id: id, amount: float, currency: str):
        &#34;&#34;&#34;Adds 1 fund into database.

                   Args:
                       country_id: id representation of country
                       branch_id: id representation of branch
                       amount: how much money was funded
                       currency: ISO 4217 of fund currency

                   Returns:
                       bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql_del = &#34;delete from funding where country_id=%(country_id)s and branch_id=%(branch_id)s&#34;

        sql = &#34;insert into funding(country_id, branch_id, absolute_funding, currency) &#34; \
              &#34;values (%(country_id)s, %(branch_id)s, %(amount)s, %(currency)s)&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_del, {&#34;country_id&#34;: country_id, &#34;branch_id&#34;: branch_id})
                    cursor.execute(sql, {&#34;country_id&#34;: country_id, &#34;branch_id&#34;: branch_id, &#34;amount&#34;: amount,
                                         &#34;currency&#34;: currency})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False


    def deleteBGS(self):
        &#34;&#34;&#34;deletes BGS table, restarts serial identity

                   Args:

                   Returns:
                       bool: true/false whether deleting was successfull
           &#34;&#34;&#34;
        sql = &#34;TRUNCATE BGS RESTART IDENTITY &#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importBGSdata(self, sport_id: id, value: int):
        &#34;&#34;&#34;add BGS record into database
                   Args:
                        sport_id: id representation of sport
                        value: int value of BGS
                   Returns:
                        bool: true/false whether import was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into BGS(sport_id, value) &#34; \
                &#34;values (%(sport_id)s, %(value)s)&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_id&#34;: sport_id,  &#34;value&#34;: value})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False



    def deleteSuccesTables(self):
        &#34;&#34;&#34;deletes all tables that are used with success data
                   Args:

                   Returns:
                        bool: true/false whether deleting was successfull
        &#34;&#34;&#34;
        sql = &#34;TRUNCATE  COUNTRY_BEST_ORDER, TOTAL_COUNTRY_POINTS,&#34; \
              &#34; MAX_POINTS_IN_SPORT, NUM_IN_SPORT, success RESTART IDENTITY &#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importSuccessdata(self, sport_id: id, country_id: id, points: float, orders: int):
        &#34;&#34;&#34;add success record into DB
                   Args:
                        sport_id: id representation of sport
                        country_id: id representation of country
                        points: float, how many points did country get in sport
                        orders: int, in which place did the country ended up
                   Returns:
                        bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into success(sport_id, country_id, points, orders) &#34; \
              &#34;values (%(sport_id)s, %(country_id)s, %(points)s, %(orders)s)&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_id&#34;: sport_id, &#34;country_id&#34;: country_id, &#34;points&#34;: points,
                                         &#34;orders&#34;: orders})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importNumberInSports(self, sport_id: id, num_countries: int):
        &#34;&#34;&#34;add how many sports were ranked in specific sport
                   Args:
                        sport_id: id represenation of sport,
                        num_countries: how many countries are in the success ranking
                   Returns:
                        bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into NUM_IN_SPORT(sport_id, num_countries) &#34; \
              &#34;values (%(sport_id)s, %(num_countries)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_id&#34;: sport_id, &#34;num_countries&#34;: num_countries})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importMaxPointsInSport(self, sport_id: id, points: float):
        &#34;&#34;&#34;add highest points in specific sport
                         Args:
                              sport_id: id represenation of sport,
                              points: maximum of the points in sport
                         Returns:
                              bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into MAX_POINTS_IN_SPORT(sport_id, points) &#34; \
              &#34;values (%(sport_id)s, %(points)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_id&#34;: sport_id, &#34;points&#34;: points})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importTotalCountryPoints(self, country_id: id, points: float):
        &#34;&#34;&#34;add sum of points above all sports for specific country
                         Args:
                              country_id: id represenation of country,
                              points: sum of points from all sports
                         Returns:
                              bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into TOTAL_COUNTRY_POINTS(country_id, points) &#34; \
              &#34;values (%(country_id)s, %(points)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_id&#34;: country_id, &#34;points&#34;: points})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importCountryBestOrder(self, country_id: id, best: int):
        &#34;&#34;&#34;add best placement of specific country
                         Args:
                              country_id: id represenation of country,
                              points: best placement of country
                         Returns:
                              bool: true/false whether importing was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into COUNTRY_BEST_ORDER(country_id, best) &#34; \
              &#34;values (%(country_id)s, %(best)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_id&#34;: country_id, &#34;best&#34;: best})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False


    def deleteInterconnectednessTables(self, type_id: id):
        &#34;&#34;&#34;deletes data from interconnectedness table, with specific type_id
                         Args:
                              type_id: type of interconnectedness ( 1 economic, 2 non-economic )

                         Returns:
                              bool: true/false whether deleting was successfull
        &#34;&#34;&#34;
        sql_del = &#34;DELETE FROM interconnectness WHERE type_id =%(type_id)s   &#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql_del, {&#34;type_id&#34;: type_id})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def importInterconnectednessData(self, type_id: id, country_one_id: id, country_two_id: id, value: float):
        &#34;&#34;&#34;imports interconnectedness record
                              Args:
                                   type_id: type of interconnectedness ( 1 economic, 2 non-economic )
                                   country_one_id: id representation of country
                                   country_two_id: id representation of country ( they can not match )
                                   value: value of interconnectedness between country1 and country2

                              Returns:
                                   bool: true/false whether deleting was successfull
        &#34;&#34;&#34;
        sql = &#34;insert into interconnectness(type_id, country_one_id, country_two_id, value ) &#34; \
              &#34;values (%(type_id)s, %(country_one_id)s, %(country_two_id)s , %(value)s)&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;type_id&#34;: type_id, &#34;country_one_id&#34;: country_one_id,
                                         &#34;country_two_id&#34;: country_two_id, &#34;value&#34;: value})
                dbConn.commit()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return True
        except psycopg2.DatabaseError as error:
            #print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    # getters for DB mirroring in data computation modul

    def getBGS(self) -&gt; Dict[str, List[Dict[str, Any]]]:
        &#34;&#34;&#34; Get all records from table BGS.

        Returns:
            Dict[str, List[Dict[str, Any]]]: dict with one key BGS,
            which value is list of dicts with keys sport_id, value
        &#34;&#34;&#34;

        sql = &#34;select sport_id, value from BGS&#34;
        result = {&#34;BGS&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;BGS&#34;].append({&#34;sport_id&#34;: tmp[0], &#34;value&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            result = result[&#34;BGS&#34;]
            final_result = {}

            for record in result:
                final_result[record[&#34;sport_id&#34;]] = record[&#34;value&#34;]

            return final_result

    def getOrder(self) -&gt; Dict[int, Dict[int, int]]:
        &#34;&#34;&#34; Get order of each country in each sport from table success .

        Returns:
            Dict[int, Dict[int, int]]:  dict with keys = country ids, its value is dict
            with items sport id -&gt; order
        &#34;&#34;&#34;

        sql = &#34;select country_id, sport_id, orders from success&#34;
        result = {&#34;order&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, sport_id, order = tmp
                        result[&#34;order&#34;].append({&#34;country_id&#34;: country_id, &#34;sport_id&#34;: sport_id, &#34;order&#34;: order})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;order&#34;]:

                country_id, sport_id, order = record[&#34;country_id&#34;], record[&#34;sport_id&#34;], record[&#34;order&#34;]

                if record[&#34;country_id&#34;] not in final_result:
                    final_result[country_id] = {}

                final_result[country_id][sport_id] = order

            return final_result

    def getPoints(self) -&gt; Dict[id, Dict[id, float]]:
        &#34;&#34;&#34; Get points of each country in each sport from table success .

        Returns:
             Dict[id, Dict[id, float]]:  dict with keys = country ids, its value is dict
            with items sport id -&gt; points
        &#34;&#34;&#34;

        sql = &#34;select country_id, sport_id, points from success&#34;
        result = {&#34;points&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, sport_id, points = tmp
                        result[&#34;points&#34;].append({&#34;country_id&#34;: country_id, &#34;sport_id&#34;: sport_id, &#34;points&#34;: points})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;points&#34;]:

                country_id, sport_id, points = record[&#34;country_id&#34;], record[&#34;sport_id&#34;], record[&#34;points&#34;]

                if record[&#34;country_id&#34;] not in final_result:
                    final_result[country_id] = {}

                final_result[country_id][sport_id] = points

            return final_result

    def getMaxPoints(self) -&gt; Dict[id, float]:
        &#34;&#34;&#34; Get maximum points for each country in any sport from table MAX_POINTS_IN_SPORT.

        Returns:
            Dict[id,float]:  dict with keys = sport ids, its value is max points
        &#34;&#34;&#34;

        sql = &#34;select sport_id, points from MAX_POINTS_IN_SPORT&#34;
        result = {&#34;points&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        sport_id, points = tmp
                        result[&#34;points&#34;].append({&#34;sport_id&#34;: sport_id, &#34;points&#34;: points})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;points&#34;]:
                sport_id, points = record[&#34;sport_id&#34;], record[&#34;points&#34;]

                final_result[sport_id] = points

            return final_result

    def getNumCountriesInSport(self) -&gt; Dict[id, int]:
        &#34;&#34;&#34; Getter for table NUM_IN_SPORT which contains number of countries ranked in a sport.

        Returns:
            Dict[id, int]: dict sport id -&gt; number of countries
        &#34;&#34;&#34;

        sql = &#34;select sport_id, num_countries from NUM_IN_SPORT&#34;
        result = {&#34;num&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        sport_id, num = tmp
                        result[&#34;num&#34;].append({&#34;sport_id&#34;: sport_id, &#34;num&#34;: num})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;num&#34;]:
                sport_id, num = record[&#34;sport_id&#34;], record[&#34;num&#34;]

                final_result[sport_id] = num

            return final_result

    def getTotalCountryPoints(self) -&gt; Dict[id, float]:
        &#34;&#34;&#34; Get sum of points in all sport in a country.

        Returns:
            Dict[id, float]: dict of country id -&gt; sum of points
        &#34;&#34;&#34;
        sql = &#34;select country_id, points from TOTAL_COUNTRY_POINTS&#34;
        result = {&#34;sum&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, suma = tmp
                        result[&#34;sum&#34;].append({&#34;country_id&#34;: country_id, &#34;sum&#34;: suma})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;sum&#34;]:
                country_id, suma = record[&#34;country_id&#34;], record[&#34;sum&#34;]

                final_result[country_id] = suma

            return final_result

    def getMinOrder(self) -&gt; Dict[id, float]:
        &#34;&#34;&#34;Get minimum = best order of country in any sport.

        Returns:
            Dict[id, float]: dict of country id -&gt; order
        &#34;&#34;&#34;

        sql = &#34;select country_id, best from COUNTRY_BEST_ORDER &#34;
        result = {&#34;order&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, order = tmp
                        result[&#34;order&#34;].append({&#34;country_id&#34;: country_id, &#34;order&#34;: order})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;order&#34;]:
                country_id, order = record[&#34;country_id&#34;], record[&#34;order&#34;]

                final_result[country_id] = order

            return final_result

    def getEconIntercon(self) -&gt; Dict[id, Dict[id, float]]:
        &#34;&#34;&#34; Returns all economic interconnectness records from table interconnectness.

        Returns:
            Dict[id, Dict[id, float]]: dict of country id -&gt; dict of country id -&gt; econ interconnectness
        &#34;&#34;&#34;
        sql = &#34;select country_one_id, country_two_id, value from interconnectness where type_id = 1&#34;
        result = {&#34;inter&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_one_id, country_two_id, value = tmp
                        result[&#34;inter&#34;].append(
                            {&#34;country_one_id&#34;: country_one_id, &#34;country_two_id&#34;: country_two_id, &#34;value&#34;: value})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;inter&#34;]:
                country_one_id, country_two_id, value = record[&#34;country_one_id&#34;], record[&#34;country_two_id&#34;], record[
                    &#34;value&#34;]

                if country_one_id not in final_result:
                    final_result[country_one_id] = {}

                final_result[country_one_id][country_two_id] = value

            return final_result

    def getNonEconIntercon(self) -&gt; Dict[id, Dict[id, float]]:
        &#34;&#34;&#34; Returns all non economic interconnectness records from table interconnectness.

        Returns:
            Dict[id, Dict[id, float]]: dict of country id -&gt; dict of country id -&gt; non econ interconnectness
        &#34;&#34;&#34;
        sql = &#34;select country_one_id, country_two_id, value from interconnectness where type_id = 2&#34;
        result = {&#34;inter&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_one_id, country_two_id, value = tmp
                        result[&#34;inter&#34;].append(
                            {&#34;country_one_id&#34;: country_one_id, &#34;country_two_id&#34;: country_two_id, &#34;value&#34;: value})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;inter&#34;]:
                country_one_id, country_two_id, value = record[&#34;country_one_id&#34;], record[&#34;country_two_id&#34;], record[
                    &#34;value&#34;]

                if country_one_id not in final_result:
                    final_result[country_one_id] = {}

                final_result[country_one_id][country_two_id] = value

            return final_result

    def getNonCombiBranchFunding(self) -&gt; Dict[id, Dict[id, Dict[id, float]]]:
        &#34;&#34;&#34; Get all funding records for NONcombi branches from table funding.

        Returns:
            Dict[id, Dict[id, Dict[id, float]]]: dict of country id -&gt; dict of sport id -&gt;
            dict of branch id -&gt; total non combi branch funding
        &#34;&#34;&#34;
        sql = &#34;select f.country_id, sport_id, branch_id, sum(absolute_funding)  from funding f join branch b  &#34; \
              &#34;on b.id = f.branch_id  and is_combined = false group by f.country_id, sport_id, branch_id&#34;
        result = {&#34;funding&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        country_id, sport_id, branch_id, suma = tmp
                        result[&#34;funding&#34;].append(
                            {&#34;country_id&#34;: country_id, &#34;sport_id&#34;: sport_id, &#34;branch_id&#34;: branch_id, &#34;sum&#34;: suma})
                        tmp = cursor.fetchone()

            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            final_result = {}

            for record in result[&#34;funding&#34;]:
                country_id, sport_id, branch_id, suma = record[&#34;country_id&#34;], record[&#34;sport_id&#34;], record[&#34;branch_id&#34;], \
                                                        record[&#34;sum&#34;]

                if country_id not in final_result:
                    final_result[country_id] = {}

                if sport_id not in final_result[country_id]:
                    final_result[country_id][sport_id] = {}

                final_result[country_id][sport_id][branch_id] = suma

            return final_result

    def getActiveCountryIds(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34; Returns active country data.

        Returns:
            List[Dict[str, Any]]: list of dicts, each dict contain keyd id, name = description of country.
        &#34;&#34;&#34;
        sql = &#34;select id, name from country where is_active = true&#34;
        result = {&#34;countries&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;countries&#34;].append({&#34;id&#34;: tmp[0], &#34;name&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;countries&#34;]


    def getActiveCountryTranslations(self) -&gt; list:
        &#34;&#34;&#34; Returns active country data with translations.

              Returns:
                  List[Dict[str, Any]]: list of dicts, each dict contain keyd id, translation = translation of country
              &#34;&#34;&#34;
        sql = &#34;select id, translation from country where is_active = true&#34;
        result = {&#34;countries&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;countries&#34;].append({&#34;id&#34;: tmp[0], &#34;translation&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;countries&#34;]

    def getSportIds(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34; Returns sports data from table sport.

        Returns:
            List[Dict[str, Any]]: list of dicts, each dict contain keys id, title = description of sport.
        &#34;&#34;&#34;
        sql = &#34;select id, title from sport&#34;
        result = {&#34;sports&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;sports&#34;].append({&#34;id&#34;: tmp[0], &#34;title&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;sports&#34;]

    def getCombiFunding(self) -&gt; Dict[id, Dict[id, Dict[id, float]]]:

        &#34;&#34;&#34; Get all funding records for combi branches from table funding.

        Returns:
            Dict[id, Dict[id, Dict[id, float]]]: dict of country id -&gt; subbranch id -&gt; combi branch id -&gt; funding
        &#34;&#34;&#34;

        sql = &#34;select b.country_id,  cb.subbranch_id, cb.combi_branch_id, absolute_funding * coefficient as fund &#34; \
              &#34;from branch b join combi_branch cb on b.id = cb.combi_branch_id &#34; \
              &#34;join funding f on f.country_id = b.country_id and f.branch_id = cb.combi_branch_id&#34;

        result = {&#34;funding&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;funding&#34;].append(
                            {&#34;country_id&#34;: tmp[0], &#34;subbranch_id&#34;: tmp[1], &#34;combi_branch_id&#34;: tmp[2], &#34;fund&#34;: tmp[3]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            final_result = {}

            for record in result[&#34;funding&#34;]:

                country_id, subbranch_id, combi_branch_id, fund = record[&#34;country_id&#34;], record[&#34;subbranch_id&#34;], record[
                    &#34;combi_branch_id&#34;], record[&#34;fund&#34;]

                if country_id not in final_result:
                    final_result[country_id] = {}

                if subbranch_id not in final_result[country_id]:
                    final_result[country_id][subbranch_id] = {}

                if combi_branch_id in final_result[country_id][subbranch_id]:
                    final_result[country_id][subbranch_id][combi_branch_id] += fund
                else:
                    final_result[country_id][subbranch_id][combi_branch_id] = fund

            return final_result

    def getNonCombiBranchIds(self) -&gt; List[Dict[str, id]]:

        &#34;&#34;&#34; Returns all ids of non combi branches in table branch.

        Returns:
            Dict[str, id]: list of dicts with key &#39;id&#39; and value combi branch id
        &#34;&#34;&#34;

        sql = &#34;select id from branch where is_combined = false&#34;
        result = {&#34;branches&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;branches&#34;].append({&#34;id&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;branches&#34;]

    def getTotalBranchFunding(self) -&gt; Dict[id, Dict[id, float]]:
        &#34;&#34;&#34;Returns total branch fnding = sum of direct funding and funding from combi branches.

        Returns:
            Dict[id, Dict[id, float]]: dict of country id -&gt; dict of branch id -&gt; total funding
        &#34;&#34;&#34;

        sql = &#34;&#34;&#34;select country_id, branch_id, sum(absolute_funding) from

            ((
                select f.country_id, branch_id, absolute_funding
                from funding f join branch b  
                on b.id = f.branch_id  and is_combined = false  
            )
            union
            (
                select b.country_id, cb.subbranch_id as branch_id, absolute_funding * coefficient as absolute_funding 
                from branch b join combi_branch cb on b.id = cb.combi_branch_id
                join funding f on f.country_id = b.country_id and f.branch_id = cb.combi_branch_id
                
            )) as x
            
            group by country_id, branch_id
            order by country_id, branch_id
            &#34;&#34;&#34;
        result = {&#34;funding&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;funding&#34;].append(
                            {&#34;country_id&#34;: tmp[0], &#34;branch_id&#34;: tmp[1], &#34;absolute_funding&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            final_result = {}

            for record in result[&#34;funding&#34;]:
                country_id, branch_id, absolute_funding = record[&#34;country_id&#34;], record[&#34;branch_id&#34;], record[
                    &#34;absolute_funding&#34;]

                if country_id not in final_result:
                    final_result[country_id] = {}

                final_result[country_id][branch_id] = absolute_funding

            return final_result

    def getNonCombiWithSportBranchIds(self) -&gt; Dict[id, List[id]]:
        &#34;&#34;&#34; Get non combi branch ids with sport it belongs to.

        Returns:
            Dict[id, List[id]]: dict of sport id -&gt; list of branch ids in this sport
        &#34;&#34;&#34;
        sql = &#34;select id, sport_id from branch where is_combined = false&#34;
        result = {&#34;branches&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;branches&#34;].append({&#34;id&#34;: tmp[0], &#34;sport_id&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            final_result = {}
            for record in result[&#34;branches&#34;]:
                sport_id, id = record[&#34;sport_id&#34;], record[&#34;id&#34;]
                if sport_id not in final_result:
                    final_result[sport_id] = []
                final_result[sport_id].append(id)
            return final_result

    def getAllSportInfo(self) -&gt; Dict[Any, Tuple[Any, Any]]:
        &#34;&#34;&#34; Get records from table sport.

        Returns:
            Dict[Any, Tuple[Any, Any]]: dict of sport id -&gt; (sport code, sport title)
        &#34;&#34;&#34;
        sql = &#34;select id, code, title from sport&#34;
        result = {&#34;sports&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;sports&#34;].append({&#34;id&#34;: tmp[0], &#34;code&#34;: tmp[1], &#34;title&#34;: tmp[2]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)

            final_result = {}
            for record in result[&#34;sports&#34;]:
                id, code, title = record[&#34;id&#34;], record[&#34;code&#34;], record[&#34;title&#34;]
                final_result[id] = (code, title)
            return final_result

    def checkCodeTitle(self, sport_code: int, branch_code: int, sport_title: str, branch_title: str) -&gt; bool:
        &#34;&#34;&#34; Check if branch and sport with sport code and branch code and titles exist and belongs together.

        Args:
            sport_code (int): selected sport code
            branch_code (int): selected branch code
            sport_title (str): selected sport title
            branch_title (str): selected branch title

        Returns:
            bool: true/false whether branch belongs to sport
        &#34;&#34;&#34;
        sql = &#34;select * from sport s join branch b on s.id = b.sport_id and s.code = %(sport_code)s &#34; \
              &#34;and b.code = %(branch_code)s and s.title = %(sport_title)s and b.title = %(branch_title)s &#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql,
                                   {&#34;sport_code&#34;: sport_code, &#34;branch_code&#34;: branch_code, &#34;sport_title&#34;: sport_title,
                                    &#34;branch_title&#34;: branch_title})
                    tmp = cursor.fetchone()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return tmp is not None
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return False

    def findSportByCode(self, sport_code: int) -&gt; str:
        &#34;&#34;&#34;Returns title of sport by entered code.

        Args:
            sport_code (int): selected sport code

        Returns:
            str: sport title
        &#34;&#34;&#34;

        sql = &#34;select title from sport where code = %(sport_code)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_code&#34;: sport_code})
                    tmp = cursor.fetchone()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return tmp[0] if tmp is not None else None
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return &#34;&#34;

    def findBranchByCode(self, sport_code: int, branch_code: int) -&gt; str:
        &#34;&#34;&#34;Returns branch title of branch defined by entered sport and branch code.

        Args:
            sport_code (int): selected sport code
            branch_code (int): selected branch code

        Returns:
            str: branch title
        &#34;&#34;&#34;

        sql = &#34;select b.title from branch b join sport s on s.id = b.sport_id &#34; \
              &#34;and s.code = %(sport_code)s and b.code = %(branch_code)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_code&#34;: sport_code, &#34;branch_code&#34;: branch_code})
                    tmp = cursor.fetchone()
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return tmp[0] if tmp is not None else None
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)
            return &#34;&#34;

    def getSportBranches(self, sport_code: int) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Returns all branches which belongs to entered sport.

        Args:
            sport_code (int): selected sport code

        Returns:
            List[Dict[str, Any]]: list of dicts , each dict contains keys code, title.
        &#34;&#34;&#34;

        sql = &#34;select b.code, b.title from branch b join sport s &#34; \
              &#34;on b.sport_id = s.id and s.code = %(code)s&#34;
        result = {&#34;branches&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;code&#34;: sport_code})
                    tmp = cursor.fetchone()
                    while tmp:
                        result[&#34;branches&#34;].append({&#34;code&#34;: tmp[0], &#34;title&#34;: tmp[1]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)

        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)

        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return result[&#34;branches&#34;]

    def showCombiBranches(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Returns data about combi branches from table combi_branch.

        Returns:
            List[Dict[str, Any]]: list of dicts , each dict contains keys countryCode, countryName,
            combiCode, combiTitle, subCode, subTitle, coefficient
        &#34;&#34;&#34;

        sql = &#34;select c.code, c.name, b.code, b.title, b2.code, b2.title, coefficient &#34; \
              &#34;from combi_branch cb join branch b on combi_branch_id = b.id &#34; \
              &#34;join branch b2 on subbranch_id = b2.id &#34; \
              &#34;join country c on b.country_id = c.id&#34;
        results = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        results.append(
                            {&#34;countryCode&#34;: tmp[0], &#34;countryName&#34;: tmp[1], &#34;combiCode&#34;: tmp[2], &#34;combiTitle&#34;: tmp[3],
                             &#34;subCode&#34;: tmp[4], &#34;subTitle&#34;: tmp[5], &#34;coefficient&#34;: tmp[6]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            # print(result)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return results

    def checkCombi(self, branch_code: int, country_code: str) -&gt; Tuple[int, str]:
        &#34;&#34;&#34; Check existance of combi branch. If exists, returns code, title else -1 and empty.

        Args:
            branch_code ([type]): selected branch code
            country_code ([type]): selected country code

        Returns:
             Tuple[int, str]: (branch code, country code)
        &#34;&#34;&#34;

        sql = &#34;select b.code, b.title from branch b join country c &#34; \
              &#34;on c.id = b.country_id and c.code = %(country_code)s and is_combined and b.code = %(branch_code)s &#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;branch_code&#34;: branch_code, &#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return -1, &#34;&#34;
                    else:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return tmp[0], tmp[1]

        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def suggestNewSportCode(self) -&gt; int:
        &#34;&#34;&#34; Returns suggestion for sport code.

        Returns:
            int: suggestion for sport code
        &#34;&#34;&#34;

        sql = &#34;select max(code)+1 from sport&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0] if tmp[0] is not None else 1
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def countryCodeToID(self, country_code: str) -&gt; id:
        &#34;&#34;&#34; Convert country code to country id.

        Args:
            country_code (str):  selected country code

        Returns:
            id: id of the country with selected code, if not exist then -1
        &#34;&#34;&#34;

        sql = &#34;select id from country where code=%(country_code)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;country_code&#34;: country_code})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return -1
                    else:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return tmp[0]

        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def suggestNewBranchCode(self, sport_code: int) -&gt; int:
        &#34;&#34;&#34; Returns suggestion for branch code in entered sport.

        Args:
            sport_code (int): selected sport code

        Returns:
            int: suggestion for branch code under selected sport
        &#34;&#34;&#34;

        sql = &#34;select max(b.code)+1 from branch b &#34; \
              &#34;join sport s on s.id = b.sport_id and s.code = %(sport_code)s&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;sport_code&#34;: sport_code})
                    tmp = cursor.fetchone()
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0] if tmp[0] is not None else 1
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def branchCodeToId(self, sport_code: int, branch_code: int) -&gt; id:
        &#34;&#34;&#34; Convert branch code to id.
            Branch is defined by branch code and sport code it belongs to.


        Args:
            sport_code (int): selected sport code
            branch_code (int): selected branch code

        Returns:
            id: return branch id
        &#34;&#34;&#34;

        sql = &#34;select b.id from branch b join sport s on s.id = b.sport_id and &#34; \
              &#34; b.code = %(branch_code)s and s.code =  %(sport_code)s &#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;branch_code&#34;: branch_code, &#34;sport_code&#34;: sport_code})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return -1
                    else:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return tmp[0]
        except psycopg2.DatabaseError as error:
            # print(error)
            #print(dbConn)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def suggestNewCombiBranchCode(self) -&gt; int:
        &#34;&#34;&#34; Returns suggestion for combi branch code.

        Returns:
            int: suggestion for new combi branch code
        &#34;&#34;&#34;
        sql = &#34;select max(b.code)+1 from branch b where is_combined&#34;
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0] if tmp[0] is not None else 10000
        except psycopg2.DatabaseError as error:
            # print(error)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def getSportsWithExisitingBranch(self) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34; Returns sports from table sport which have at least one branch.
            
        Returns:
            List[Dict[str, Any]]: list of dicts , each dict contains keys title, code.

        &#34;&#34;&#34;
        sql = &#34;select s.code, s.title from sport s &#34; \
              &#34; where exists(select * from branch where sport_id = s.id) &#34;

        sports = []
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        sports.append({&#34;title&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                        tmp = cursor.fetchone()
            # self._releaseConnection(dbConn)
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return sports

    def combiBranchCodeToId(self, branch_code: int) -&gt; id:
        &#34;&#34;&#34; Convert combi branch code to id.

        Args:
            branch_code (int): selected branch code

        Returns:
            id: return id of combi branch
        &#34;&#34;&#34;

        sql = &#34;select b.id from branch b where is_combined and code = %(code)s&#34;

        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql, {&#34;code&#34;: branch_code})
                    tmp = cursor.fetchone()
                    if tmp is None:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return -1
                    else:
                        if &#34;dbConn&#34; in locals():
                            self._releaseConnection(dbConn)
                        return tmp[0]
        except psycopg2.DatabaseError as error:
            # print(error)
            #print(dbConn)
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            self.logger.error(error)

    def getInterconnTypes(self) -&gt; Dict[str, list]:
        &#34;&#34;&#34; Returns interconnectness types from table interconnectness_type.

        Returns:
            Dict[str, list]: list of dicts , each dict contains keys title, code.
        &#34;&#34;&#34;

        sql = &#34;select code, title from interconnectness_type&#34;
        results = {&#34;interconnectnesstype&#34;: []}
        try:
            with self._getConnection() as dbConn:
                with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    cursor.execute(sql)
                    tmp = cursor.fetchone()
                    while tmp:
                        results[&#34;interconnectnesstype&#34;].append({&#34;code&#34;: tmp[0], &#34;title&#34;: tmp[1]})
                        tmp = cursor.fetchone()
        except psycopg2.DatabaseError as error:
            # print(error)
            self.logger.error(error)
        finally:
            if &#34;dbConn&#34; in locals():
                self._releaseConnection(dbConn)
            return results</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="__init__.Database.createDatabaseBackup"><code class="name flex">
<span>def <span class="ident">createDatabaseBackup</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create (save) backup of current version of the database.
Saved file names are in format sport_db_backup{timestamp_in_ms}.bak</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def createDatabaseBackup():
    &#34;&#34;&#34; Create (save) backup of current version of the database.
        Saved file names are in format sport_db_backup{timestamp_in_ms}.bak
    &#34;&#34;&#34;
    DB_HOST = env.get(&#34;DB_HOST&#34;)
    DB_NAME = env.get(&#34;DB_NAME&#34;)
    DB_USER = env.get(&#34;DB_USER&#34;)
    DB_PASS = env.get(&#34;DB_PASS&#34;)
    system(f&#39;pg_dump &#34;host={DB_HOST} port=5432 dbname={DB_NAME} user={DB_USER} password={DB_PASS}&#34; &gt; &#39;
           f&#39;db/backups/sport_db_backup{int(round(time() * 1000))}.bak&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="__init__.Database.addBranch"><code class="name flex">
<span>def <span class="ident">addBranch</span></span>(<span>self, data:Dict[str,Any]) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a new branch to DB.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dict with keys sportCode, branchCode, branchTitle to describe new branch</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether branch was successfully added</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addBranch(self, data: Dict[str, Any]) -&gt; bool:
    &#34;&#34;&#34; Adding a new branch to DB.

        Args:
            data (dict): dict with keys sportCode, branchCode, branchTitle to describe new branch

        Returns:
            bool: true/false whether branch was successfully added
    &#34;&#34;&#34;
    if &#34;sportCode&#34; not in data:
        raise DataError(&#34;sport code missing in data&#34;)

    if &#34;branchCode&#34; not in data:
        raise DataError(&#34;branch code not in data&#34;)

    if &#34;branchTitle&#34; not in data:
        raise DataError(&#34;branch title not in data&#34;)

    sql_sport = &#34;select id from sport where code = %(sport_code)s&#34;
    sql_check = &#34;select s.id, b.title from sport s join branch b on s.id = b.sport_id &#34; \
                &#34;and s.code = %(sport_code)s and b.code = %(branch_code)s&#34;
    sql = &#34;insert into branch(code, title, is_combined, sport_id) &#34; \
          &#34;values ( %(code)s, %(title)s, %(is_combined)s, %(sport_id)s )&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql_sport, {&#34;sport_code&#34;: data[&#34;sportCode&#34;]})
                tmp = cursor.fetchone()
                if tmp is None:
                    self._releaseConnection(dbConn)

                    raise DataError(
                        f&#34;unable to insert, sport with entered code doesnt exist, please select another code&#34;)
                sport_id = tmp[0]

                cursor.execute(sql_check, {&#34;sport_code&#34;: data[&#39;sportCode&#39;], &#34;branch_code&#34;: data[&#39;branchCode&#39;]})
                tmp = cursor.fetchone()
                if tmp is not None:  # branch code already exists
                    self._releaseConnection(dbConn)
                    raise DataError(
                        f&#34;unable to insert, branch with entered code already exists - {tmp[1]}, &#34;
                        f&#34;please select another code&#34;)

                cursor.execute(sql,
                               {&#34;code&#34;: data[&#39;branchCode&#39;], &#34;title&#34;: data[&#39;branchTitle&#39;], &#34;is_combined&#34;: &#39;false&#39;,
                                &#34;sport_id&#34;: sport_id})
                dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except (psycopg2.DatabaseError, DataError) as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.addCombiBranch"><code class="name flex">
<span>def <span class="ident">addCombiBranch</span></span>(<span>self, data:Dict[str,Any]) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a new combi branch to DB.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dict with items branchCode -&gt; int , branchTitle -&gt; str, countryCode -&gt; str, subBranches -&gt; list</dd>
</dl>
<p>subbranches value is list of dicts with keys sportCode, branchCode, coefficient which describe subbranch</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether combi branch was successfully added</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addCombiBranch(self, data: Dict[str, Any]) -&gt; bool:
    &#34;&#34;&#34; Adding a new combi branch to DB.

    Args:
        data (dict): dict with items branchCode -&gt; int , branchTitle -&gt; str, countryCode -&gt; str, subBranches -&gt; list
        subbranches value is list of dicts with keys sportCode, branchCode, coefficient which describe subbranch


    Returns:
        bool: true/false whether combi branch was successfully added

    &#34;&#34;&#34;

    if &#34;branchCode&#34; not in data:
        raise DataError(&#34;branch code missing in data&#34;)

    if &#34;branchTitle&#34; not in data:
        raise DataError(&#34;branch title missing in data&#34;)

    if &#34;countryCode&#34; not in data:
        raise DataError(&#34;country code missing in data&#34;)

    if &#34;subBranches&#34; not in data:
        raise DataError(&#34;subBranches data missing&#34;)

    if not isinstance(data[&#34;subBranches&#34;], list):
        raise DataError(&#34;invalid subBranches data structure&#34;)

    suma = 0
    try:
        for i in data[&#34;subBranches&#34;]:
            suma += i[&#34;coefficient&#34;]
        if suma != 1:
            raise DataError(&#34;coefficients sum is not 1&#34;)
    except KeyError:
        try:
            raise DataError(&#34;invalid subbranch data structure&#34;)
        except DataError as e:
            self.logger.error(e)
    except DataError as e:
        self.logger.error(e)

    sql_check_unique = &#34;select * from branch where code = %(branch_code)s&#34;
    sql_country_exists = &#34;select id from country where code = %(country_code)s&#34;
    sql_sub_exists = &#34;select b.id from branch b join sport s on s.id = b.sport_id &#34; \
                     &#34;and s.code =  %(sport_code)s and b.code = %(branch_code)s&#34;

    sql_insert = &#34;insert into branch(code, title, is_combined, country_id) &#34; \
                 &#34;values (%(code)s, %(title)s, %(is_combined)s, %(country_id)s ) returning id&#34;
    sql_connect = &#34;insert into combi_branch(combi_branch_id, subbranch_id, coefficient) &#34; \
                  &#34;values (%(combi_branch_id)s, %(subbranch_id)s, %(coefficient)s )&#34;

    inserting_data = []

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:

                cursor.execute(sql_check_unique, {&#34;branch_code&#34;: data[&#39;branchCode&#39;]})
                tmp = cursor.fetchone()
                if tmp is not None:  # branch code already exists
                    self._releaseConnection(dbConn)
                    raise DataError(&#34;branch with entered code already exists&#34;)

                cursor.execute(sql_country_exists, {&#34;country_code&#34;: data[&#34;countryCode&#34;]})
                tmp = cursor.fetchone()
                if tmp is None:
                    self._releaseConnection(dbConn)
                    raise DataError(&#34;country with entered code does not exist&#34;)
                country_id = tmp[0]

                for sub in data[&#34;subBranches&#34;]:
                    try:
                        cursor.execute(sql_sub_exists,
                                       {&#34;sport_code&#34;: sub[&#34;sportCode&#34;], &#34;branch_code&#34;: sub[&#34;branchCode&#34;]})
                    except KeyError:
                        self._releaseConnection(dbConn)
                        raise DataError(&#34;invalid subBranches data structure&#34;)
                    tmp = cursor.fetchone()
                    if tmp is None:
                        self._releaseConnection(dbConn)
                        raise DataError(&#34;subBranches does not exist&#34;)
                    else:
                        inserting_data.append((tmp[0], sub[&#34;coefficient&#34;]))

                cursor.execute(sql_insert,
                               {&#34;code&#34;: data[&#34;branchCode&#34;], &#34;title&#34;: data[&#34;branchTitle&#34;], &#34;is_combined&#34;: True,
                                &#34;country_id&#34;: country_id})
                tmp = cursor.fetchone()
                newBranchId = tmp[0]

                for item in inserting_data:
                    cursor.execute(sql_connect, {&#34;combi_branch_id&#34;: newBranchId, &#34;subbranch_id&#34;: item[0],
                                                 &#34;coefficient&#34;: item[1]})

                dbConn.commit()

        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except (psycopg2.DatabaseError, DataError) as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.addCountry"><code class="name flex">
<span>def <span class="ident">addCountry</span></span>(<span>self, data:Dict[str,Any]) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Activating inactive or adding a new country to DB.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dict with keys name, translation, code which describe country</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether combi country was successfully added / activated</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addCountry(self, data: Dict[str, Any]) -&gt; bool:
    &#34;&#34;&#34; Activating inactive or adding a new country to DB.

    Args:
        data (dict): dict with keys name, translation, code which describe country

    Returns:
        bool: true/false whether combi country was successfully added / activated
    &#34;&#34;&#34;

    if &#34;name&#34; not in data:
        raise DataError(&#34;country name missing in data&#34;)

    if &#34;translation&#34; not in data:
        raise DataError(&#34;translation to slovak missing in data&#34;)

    if &#34;code&#34; not in data:
        raise DataError(&#34;country code missing in data&#34;)

    sql_check = &#34;select name, is_active from country where code=%(code)s&#34;
    sql_activate = &#34;update country set is_active = true where code = %(code)s&#34;
    sql_add = &#34;insert into country(name, is_active, translation, code) &#34; \
              &#34;values ( %(name)s, %(is_active)s, %(translation)s, %(code)s )&#34;

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:

                cursor.execute(sql_check, {&#34;code&#34;: data[&#39;code&#39;]})
                tmp = cursor.fetchone()
                if tmp is None:  # adding completely new country

                    cursor.execute(sql_add,
                                   {&#34;name&#34;: data[&#34;name&#34;], &#34;is_active&#34;: True, &#34;translation&#34;: data[&#34;translation&#34;],
                                    &#34;code&#34;: data[&#34;code&#34;]})
                    dbConn.commit()

                else:  # activating country

                    if tmp[1] is True or tmp[0] != data[&#34;name&#34;]:  # country already active
                        self._releaseConnection(dbConn)
                        raise DataError(
                            f&#34;country with entered code already exists - {tmp[0]}, please select another code&#34;)

                    cursor.execute(sql_activate, {&#34;code&#34;: data[&#34;code&#34;]})
                    dbConn.commit()

        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except (psycopg2.DatabaseError, DataError) as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.addSport"><code class="name flex">
<span>def <span class="ident">addSport</span></span>(<span>self, code:str, title:str) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a new sport to DB.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code></dt>
<dd>code of new sport</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>title of new sport</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether sport was successfully added</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addSport(self, code: str, title: str) -&gt; bool:
    &#34;&#34;&#34; Adding a new sport to DB.

        Args:
            code (str): code of new sport
            title (str): title of new sport

        Returns:
            bool: true/false whether sport was successfully added
    &#34;&#34;&#34;
    sql_check = &#34;select * from sport where code = %(code)s&#34;
    sql = &#34;insert into sport(code, title) values (%(code)s, %(title)s);&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql_check, {&#34;code&#34;: code})
                tmp = cursor.fetchone()
                if tmp is not None:  # sport code already exists
                    self._releaseConnection(dbConn)
                    raise DataError(
                        &#34;unable to insert, sport with entered code already exists, please select another code&#34;)
                cursor.execute(sql, {&#34;code&#34;: code, &#34;title&#34;: title})
                dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except (psycopg2.DatabaseError, DataError) as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.branchCodeToId"><code class="name flex">
<span>def <span class="ident">branchCodeToId</span></span>(<span>self, sport_code:int, branch_code:int) ><built-infunctionid></span>
</code></dt>
<dd>
<div class="desc"><p>Convert branch code to id.
Branch is defined by branch code and sport code it belongs to.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected sport code</dd>
<dt><strong><code>branch_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected branch code</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>id</code></dt>
<dd>return branch id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def branchCodeToId(self, sport_code: int, branch_code: int) -&gt; id:
    &#34;&#34;&#34; Convert branch code to id.
        Branch is defined by branch code and sport code it belongs to.


    Args:
        sport_code (int): selected sport code
        branch_code (int): selected branch code

    Returns:
        id: return branch id
    &#34;&#34;&#34;

    sql = &#34;select b.id from branch b join sport s on s.id = b.sport_id and &#34; \
          &#34; b.code = %(branch_code)s and s.code =  %(sport_code)s &#34;

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;branch_code&#34;: branch_code, &#34;sport_code&#34;: sport_code})
                tmp = cursor.fetchone()
                if tmp is None:
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return -1
                else:
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0]
    except psycopg2.DatabaseError as error:
        # print(error)
        #print(dbConn)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)</code></pre>
</details>
</dd>
<dt id="__init__.Database.checkCodeTitle"><code class="name flex">
<span>def <span class="ident">checkCodeTitle</span></span>(<span>self, sport_code:int, branch_code:int, sport_title:str, branch_title:str) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if branch and sport with sport code and branch code and titles exist and belongs together.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected sport code</dd>
<dt><strong><code>branch_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected branch code</dd>
<dt><strong><code>sport_title</code></strong> :&ensp;<code>str</code></dt>
<dd>selected sport title</dd>
<dt><strong><code>branch_title</code></strong> :&ensp;<code>str</code></dt>
<dd>selected branch title</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether branch belongs to sport</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkCodeTitle(self, sport_code: int, branch_code: int, sport_title: str, branch_title: str) -&gt; bool:
    &#34;&#34;&#34; Check if branch and sport with sport code and branch code and titles exist and belongs together.

    Args:
        sport_code (int): selected sport code
        branch_code (int): selected branch code
        sport_title (str): selected sport title
        branch_title (str): selected branch title

    Returns:
        bool: true/false whether branch belongs to sport
    &#34;&#34;&#34;
    sql = &#34;select * from sport s join branch b on s.id = b.sport_id and s.code = %(sport_code)s &#34; \
          &#34;and b.code = %(branch_code)s and s.title = %(sport_title)s and b.title = %(branch_title)s &#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql,
                               {&#34;sport_code&#34;: sport_code, &#34;branch_code&#34;: branch_code, &#34;sport_title&#34;: sport_title,
                                &#34;branch_title&#34;: branch_title})
                tmp = cursor.fetchone()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return tmp is not None
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.checkCombi"><code class="name flex">
<span>def <span class="ident">checkCombi</span></span>(<span>self, branch_code:int, country_code:str) >Tuple[int,str]</span>
</code></dt>
<dd>
<div class="desc"><p>Check existance of combi branch. If exists, returns code, title else -1 and empty.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>branch_code</code></strong> :&ensp;<code>[type]</code></dt>
<dd>selected branch code</dd>
<dt><strong><code>country_code</code></strong> :&ensp;<code>[type]</code></dt>
<dd>selected country code</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[int, str]</code></dt>
<dd>(branch code, country code)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkCombi(self, branch_code: int, country_code: str) -&gt; Tuple[int, str]:
    &#34;&#34;&#34; Check existance of combi branch. If exists, returns code, title else -1 and empty.

    Args:
        branch_code ([type]): selected branch code
        country_code ([type]): selected country code

    Returns:
         Tuple[int, str]: (branch code, country code)
    &#34;&#34;&#34;

    sql = &#34;select b.code, b.title from branch b join country c &#34; \
          &#34;on c.id = b.country_id and c.code = %(country_code)s and is_combined and b.code = %(branch_code)s &#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;branch_code&#34;: branch_code, &#34;country_code&#34;: country_code})
                tmp = cursor.fetchone()
                if tmp is None:
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return -1, &#34;&#34;
                else:
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0], tmp[1]

    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)</code></pre>
</details>
</dd>
<dt id="__init__.Database.combiBranchCodeToId"><code class="name flex">
<span>def <span class="ident">combiBranchCodeToId</span></span>(<span>self, branch_code:int) ><built-infunctionid></span>
</code></dt>
<dd>
<div class="desc"><p>Convert combi branch code to id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>branch_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected branch code</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>id</code></dt>
<dd>return id of combi branch</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combiBranchCodeToId(self, branch_code: int) -&gt; id:
    &#34;&#34;&#34; Convert combi branch code to id.

    Args:
        branch_code (int): selected branch code

    Returns:
        id: return id of combi branch
    &#34;&#34;&#34;

    sql = &#34;select b.id from branch b where is_combined and code = %(code)s&#34;

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;code&#34;: branch_code})
                tmp = cursor.fetchone()
                if tmp is None:
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return -1
                else:
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0]
    except psycopg2.DatabaseError as error:
        # print(error)
        #print(dbConn)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)</code></pre>
</details>
</dd>
<dt id="__init__.Database.countryCodeToID"><code class="name flex">
<span>def <span class="ident">countryCodeToID</span></span>(<span>self, country_code:str) ><built-infunctionid></span>
</code></dt>
<dd>
<div class="desc"><p>Convert country code to country id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>country_code</code></strong> :&ensp;<code>str</code></dt>
<dd>selected country code</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>id</code></dt>
<dd>id of the country with selected code, if not exist then -1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def countryCodeToID(self, country_code: str) -&gt; id:
    &#34;&#34;&#34; Convert country code to country id.

    Args:
        country_code (str):  selected country code

    Returns:
        id: id of the country with selected code, if not exist then -1
    &#34;&#34;&#34;

    sql = &#34;select id from country where code=%(country_code)s&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;country_code&#34;: country_code})
                tmp = cursor.fetchone()
                if tmp is None:
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return -1
                else:
                    if &#34;dbConn&#34; in locals():
                        self._releaseConnection(dbConn)
                    return tmp[0]

    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)</code></pre>
</details>
</dd>
<dt id="__init__.Database.deleteBGS"><code class="name flex">
<span>def <span class="ident">deleteBGS</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>deletes BGS table, restarts serial identity</p>
<p>Args:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether deleting was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteBGS(self):
    &#34;&#34;&#34;deletes BGS table, restarts serial identity

               Args:

               Returns:
                   bool: true/false whether deleting was successfull
       &#34;&#34;&#34;
    sql = &#34;TRUNCATE BGS RESTART IDENTITY &#34;

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.deleteInterconnectednessTables"><code class="name flex">
<span>def <span class="ident">deleteInterconnectednessTables</span></span>(<span>self, type_id:<built-infunctionid>)</span>
</code></dt>
<dd>
<div class="desc"><p>deletes data from interconnectedness table, with specific type_id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type_id</code></strong></dt>
<dd>type of interconnectedness ( 1 economic, 2 non-economic )</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether deleting was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteInterconnectednessTables(self, type_id: id):
    &#34;&#34;&#34;deletes data from interconnectedness table, with specific type_id
                     Args:
                          type_id: type of interconnectedness ( 1 economic, 2 non-economic )

                     Returns:
                          bool: true/false whether deleting was successfull
    &#34;&#34;&#34;
    sql_del = &#34;DELETE FROM interconnectness WHERE type_id =%(type_id)s   &#34;

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql_del, {&#34;type_id&#34;: type_id})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.deleteSuccesTables"><code class="name flex">
<span>def <span class="ident">deleteSuccesTables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>deletes all tables that are used with success data
Args:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether deleting was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteSuccesTables(self):
    &#34;&#34;&#34;deletes all tables that are used with success data
               Args:

               Returns:
                    bool: true/false whether deleting was successfull
    &#34;&#34;&#34;
    sql = &#34;TRUNCATE  COUNTRY_BEST_ORDER, TOTAL_COUNTRY_POINTS,&#34; \
          &#34; MAX_POINTS_IN_SPORT, NUM_IN_SPORT, success RESTART IDENTITY &#34;

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.findBranchByCode"><code class="name flex">
<span>def <span class="ident">findBranchByCode</span></span>(<span>self, sport_code:int, branch_code:int) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns branch title of branch defined by entered sport and branch code.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected sport code</dd>
<dt><strong><code>branch_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected branch code</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>branch title</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findBranchByCode(self, sport_code: int, branch_code: int) -&gt; str:
    &#34;&#34;&#34;Returns branch title of branch defined by entered sport and branch code.

    Args:
        sport_code (int): selected sport code
        branch_code (int): selected branch code

    Returns:
        str: branch title
    &#34;&#34;&#34;

    sql = &#34;select b.title from branch b join sport s on s.id = b.sport_id &#34; \
          &#34;and s.code = %(sport_code)s and b.code = %(branch_code)s&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;sport_code&#34;: sport_code, &#34;branch_code&#34;: branch_code})
                tmp = cursor.fetchone()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return tmp[0] if tmp is not None else None
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="__init__.Database.findSportByCode"><code class="name flex">
<span>def <span class="ident">findSportByCode</span></span>(<span>self, sport_code:int) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns title of sport by entered code.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected sport code</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>sport title</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findSportByCode(self, sport_code: int) -&gt; str:
    &#34;&#34;&#34;Returns title of sport by entered code.

    Args:
        sport_code (int): selected sport code

    Returns:
        str: sport title
    &#34;&#34;&#34;

    sql = &#34;select title from sport where code = %(sport_code)s&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;sport_code&#34;: sport_code})
                tmp = cursor.fetchone()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return tmp[0] if tmp is not None else None
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="__init__.Database.getActiveCountryIds"><code class="name flex">
<span>def <span class="ident">getActiveCountryIds</span></span>(<span>self) >List[Dict[str,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns active country data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict[str, Any]]</code></dt>
<dd>list of dicts, each dict contain keyd id, name = description of country.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveCountryIds(self) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34; Returns active country data.

    Returns:
        List[Dict[str, Any]]: list of dicts, each dict contain keyd id, name = description of country.
    &#34;&#34;&#34;
    sql = &#34;select id, name from country where is_active = true&#34;
    result = {&#34;countries&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;countries&#34;].append({&#34;id&#34;: tmp[0], &#34;name&#34;: tmp[1]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result[&#34;countries&#34;]</code></pre>
</details>
</dd>
<dt id="__init__.Database.getActiveCountryTranslations"><code class="name flex">
<span>def <span class="ident">getActiveCountryTranslations</span></span>(<span>self) >list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns active country data with translations.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict[str, Any]]</code></dt>
<dd>list of dicts, each dict contain keyd id, translation = translation of country</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveCountryTranslations(self) -&gt; list:
    &#34;&#34;&#34; Returns active country data with translations.

          Returns:
              List[Dict[str, Any]]: list of dicts, each dict contain keyd id, translation = translation of country
          &#34;&#34;&#34;
    sql = &#34;select id, translation from country where is_active = true&#34;
    result = {&#34;countries&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;countries&#34;].append({&#34;id&#34;: tmp[0], &#34;translation&#34;: tmp[1]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result[&#34;countries&#34;]</code></pre>
</details>
</dd>
<dt id="__init__.Database.getAdmin"><code class="name flex">
<span>def <span class="ident">getAdmin</span></span>(<span>self, email:str) >Optional[None]</span>
</code></dt>
<dd>
<div class="desc"><p>Use in admin login process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code></dt>
<dd>entered admin email</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[None, dict]</code></dt>
<dd>dict of record in DB which email is same as entered email</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAdmin(self, email: str) -&gt; Union[None, dict]:
    &#34;&#34;&#34; Use in admin login process.

    Args:
        email (str): entered admin email

    Returns:
        Union[None, dict]: dict of record in DB which email is same as entered email
    &#34;&#34;&#34;

    sql = &#34;select * from users where email=%s and type=&#39;admin&#39;&#34;
    result = None
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, (email,))
                result = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getAllCountries"><code class="name flex">
<span>def <span class="ident">getAllCountries</span></span>(<span>self) >List[Dict[str,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all active countries from table countries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict[str, Any]]</code></dt>
<dd>list of dicts , each dict contains keys name, code</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllCountries(self) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;  Returns all active countries from table countries.

    Returns:
        List[Dict[str, Any]]: list of dicts , each dict contains keys name, code
    &#34;&#34;&#34;

    sql = &#34;select code, name from country where is_active = true&#34;
    countries = []
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    countries.append({&#34;name&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return countries</code></pre>
</details>
</dd>
<dt id="__init__.Database.getAllSportInfo"><code class="name flex">
<span>def <span class="ident">getAllSportInfo</span></span>(<span>self) >Dict[Any,Tuple[Any,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get records from table sport.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[Any, Tuple[Any, Any]]</code></dt>
<dd>dict of sport id -&gt; (sport code, sport title)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllSportInfo(self) -&gt; Dict[Any, Tuple[Any, Any]]:
    &#34;&#34;&#34; Get records from table sport.

    Returns:
        Dict[Any, Tuple[Any, Any]]: dict of sport id -&gt; (sport code, sport title)
    &#34;&#34;&#34;
    sql = &#34;select id, code, title from sport&#34;
    result = {&#34;sports&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;sports&#34;].append({&#34;id&#34;: tmp[0], &#34;code&#34;: tmp[1], &#34;title&#34;: tmp[2]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)

        final_result = {}
        for record in result[&#34;sports&#34;]:
            id, code, title = record[&#34;id&#34;], record[&#34;code&#34;], record[&#34;title&#34;]
            final_result[id] = (code, title)
        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getAllSports"><code class="name flex">
<span>def <span class="ident">getAllSports</span></span>(<span>self) >List[Dict[str,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all sports from table sports.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict[str, Any]]</code></dt>
<dd>list of dicts , each dict contains keys title, code</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllSports(self) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34; Returns all sports from table sports.

    Returns:
        List[Dict[str, Any]]:  list of dicts , each dict contains keys title, code
    &#34;&#34;&#34;

    sql = &#34;select code, title from sport&#34;
    sports = []
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    sports.append({&#34;title&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return sports</code></pre>
</details>
</dd>
<dt id="__init__.Database.getBGS"><code class="name flex">
<span>def <span class="ident">getBGS</span></span>(<span>self) >Dict[str,List[Dict[str,Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all records from table BGS.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, List[Dict[str, Any]]]</code></dt>
<dd>dict with one key BGS,</dd>
</dl>
<p>which value is list of dicts with keys sport_id, value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBGS(self) -&gt; Dict[str, List[Dict[str, Any]]]:
    &#34;&#34;&#34; Get all records from table BGS.

    Returns:
        Dict[str, List[Dict[str, Any]]]: dict with one key BGS,
        which value is list of dicts with keys sport_id, value
    &#34;&#34;&#34;

    sql = &#34;select sport_id, value from BGS&#34;
    result = {&#34;BGS&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;BGS&#34;].append({&#34;sport_id&#34;: tmp[0], &#34;value&#34;: tmp[1]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)

        result = result[&#34;BGS&#34;]
        final_result = {}

        for record in result:
            final_result[record[&#34;sport_id&#34;]] = record[&#34;value&#34;]

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getBranchesWithSports"><code class="name flex">
<span>def <span class="ident">getBranchesWithSports</span></span>(<span>self) >List[Dict[str,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns non combi branches from table branch with sport they belong to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of dicts , each dict contains keys sportCode, sportTitle, branchCode, branchTitle.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBranchesWithSports(self) -&gt; List[Dict[str, Any]]:

    &#34;&#34;&#34;  Returns non combi branches from table branch with sport they belong to.

    Returns:
        list:  list of dicts , each dict contains keys sportCode, sportTitle, branchCode, branchTitle.
    &#34;&#34;&#34;

    sql = &#34;select s.code, s.title, b.code, b.title from sport s join branch b on b.sport_id = s.id&#34;
    results = []
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    results.append(
                        {&#34;sportCode&#34;: tmp[0], &#34;sportTitle&#34;: tmp[1], &#34;branchCode&#34;: tmp[2], &#34;branchTitle&#34;: tmp[3]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return results</code></pre>
</details>
</dd>
<dt id="__init__.Database.getCombiFunding"><code class="name flex">
<span>def <span class="ident">getCombiFunding</span></span>(<span>self) >Dict[<built-infunctionid>,Dict[<built-infunctionid>,Dict[<built-infunctionid>,float]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all funding records for combi branches from table funding.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id, Dict[id, Dict[id, float]]]</code></dt>
<dd>dict of country id -&gt; subbranch id -&gt; combi branch id -&gt; funding</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCombiFunding(self) -&gt; Dict[id, Dict[id, Dict[id, float]]]:

    &#34;&#34;&#34; Get all funding records for combi branches from table funding.

    Returns:
        Dict[id, Dict[id, Dict[id, float]]]: dict of country id -&gt; subbranch id -&gt; combi branch id -&gt; funding
    &#34;&#34;&#34;

    sql = &#34;select b.country_id,  cb.subbranch_id, cb.combi_branch_id, absolute_funding * coefficient as fund &#34; \
          &#34;from branch b join combi_branch cb on b.id = cb.combi_branch_id &#34; \
          &#34;join funding f on f.country_id = b.country_id and f.branch_id = cb.combi_branch_id&#34;

    result = {&#34;funding&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;funding&#34;].append(
                        {&#34;country_id&#34;: tmp[0], &#34;subbranch_id&#34;: tmp[1], &#34;combi_branch_id&#34;: tmp[2], &#34;fund&#34;: tmp[3]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)

        final_result = {}

        for record in result[&#34;funding&#34;]:

            country_id, subbranch_id, combi_branch_id, fund = record[&#34;country_id&#34;], record[&#34;subbranch_id&#34;], record[
                &#34;combi_branch_id&#34;], record[&#34;fund&#34;]

            if country_id not in final_result:
                final_result[country_id] = {}

            if subbranch_id not in final_result[country_id]:
                final_result[country_id][subbranch_id] = {}

            if combi_branch_id in final_result[country_id][subbranch_id]:
                final_result[country_id][subbranch_id][combi_branch_id] += fund
            else:
                final_result[country_id][subbranch_id][combi_branch_id] = fund

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getEconIntercon"><code class="name flex">
<span>def <span class="ident">getEconIntercon</span></span>(<span>self) >Dict[<built-infunctionid>,Dict[<built-infunctionid>,float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all economic interconnectness records from table interconnectness.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id, Dict[id, float]]</code></dt>
<dd>dict of country id -&gt; dict of country id -&gt; econ interconnectness</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEconIntercon(self) -&gt; Dict[id, Dict[id, float]]:
    &#34;&#34;&#34; Returns all economic interconnectness records from table interconnectness.

    Returns:
        Dict[id, Dict[id, float]]: dict of country id -&gt; dict of country id -&gt; econ interconnectness
    &#34;&#34;&#34;
    sql = &#34;select country_one_id, country_two_id, value from interconnectness where type_id = 1&#34;
    result = {&#34;inter&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    country_one_id, country_two_id, value = tmp
                    result[&#34;inter&#34;].append(
                        {&#34;country_one_id&#34;: country_one_id, &#34;country_two_id&#34;: country_two_id, &#34;value&#34;: value})
                    tmp = cursor.fetchone()

        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        final_result = {}

        for record in result[&#34;inter&#34;]:
            country_one_id, country_two_id, value = record[&#34;country_one_id&#34;], record[&#34;country_two_id&#34;], record[
                &#34;value&#34;]

            if country_one_id not in final_result:
                final_result[country_one_id] = {}

            final_result[country_one_id][country_two_id] = value

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getFundingData"><code class="name flex">
<span>def <span class="ident">getFundingData</span></span>(<span>self, country_code:str) >Dict[str,List[Dict[str,Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns funding data from table funding for selected country.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>country_code</code></strong> :&ensp;<code>str</code></dt>
<dd>selected country code</dd>
</dl>
<p>Returns: Dict[str, List[Dict[str, Any]]]: list of dicts , each dict contains keys branch_id,
absolute_funding, currency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFundingData(self, country_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
    &#34;&#34;&#34; Returns funding data from table funding for selected country.

    Args:
        country_code (str): selected country code

    Returns: Dict[str, List[Dict[str, Any]]]: list of dicts , each dict contains keys branch_id,
    absolute_funding, currency.

    &#34;&#34;&#34;

    sql = &#34;select b.title, f.absolute_funding, f.currency from funding f cross join country c &#34; \
          &#34;join branch b on c.code = %(country_code)s and f.country_id = c.id and b.id = f.branch_id&#34;
    result = {&#34;funding&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;country_code&#34;: country_code})
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;funding&#34;].append({&#34;branch_id&#34;: tmp[0], &#34;absolute_funding&#34;: tmp[1], &#34;currency&#34;: tmp[2]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getFundingDistinctCurrencies"><code class="name flex">
<span>def <span class="ident">getFundingDistinctCurrencies</span></span>(<span>self) >List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of currencies used in funding data in table funding.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of strings = currency names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFundingDistinctCurrencies(self) -&gt; List[str]:
    &#34;&#34;&#34;
        Get list of currencies used in funding data in table funding.

        Returns:
            list: list of strings = currency names.
    &#34;&#34;&#34;

    sql = &#34; select distinct currency from funding where currency != &#39;&#39; &#34;
    results = []
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
                cursor.execute(sql)
                results = cursor.fetchall()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return results</code></pre>
</details>
</dd>
<dt id="__init__.Database.getInactiveCountries"><code class="name flex">
<span>def <span class="ident">getInactiveCountries</span></span>(<span>self) >Dict[str,List[Dict[str,Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all inactive countries from table countries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dict with one key = countries, its value is</dd>
</dl>
<p>list of dicts , each dict contains keys name, code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInactiveCountries(self) -&gt; Dict[str, List[Dict[str, Any]]]:

    &#34;&#34;&#34; Get all inactive countries from table countries.

        Returns:
            dict:  dict with one key = countries, its value is
            list of dicts , each dict contains keys name, code
    &#34;&#34;&#34;

    sql = &#34;select code, name from country where is_active = false&#34;
    result = {&#34;countries&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;countries&#34;].append({&#34;name&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getInterconnTypes"><code class="name flex">
<span>def <span class="ident">getInterconnTypes</span></span>(<span>self) >Dict[str,list]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns interconnectness types from table interconnectness_type.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, list]</code></dt>
<dd>list of dicts , each dict contains keys title, code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInterconnTypes(self) -&gt; Dict[str, list]:
    &#34;&#34;&#34; Returns interconnectness types from table interconnectness_type.

    Returns:
        Dict[str, list]: list of dicts , each dict contains keys title, code.
    &#34;&#34;&#34;

    sql = &#34;select code, title from interconnectness_type&#34;
    results = {&#34;interconnectnesstype&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    results[&#34;interconnectnesstype&#34;].append({&#34;code&#34;: tmp[0], &#34;title&#34;: tmp[1]})
                    tmp = cursor.fetchone()
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return results</code></pre>
</details>
</dd>
<dt id="__init__.Database.getInterconnectnessData"><code class="name flex">
<span>def <span class="ident">getInterconnectnessData</span></span>(<span>self, type_id:int, country_code:str) >Dict[str,List[Dict[str,Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns data from table interconnectness for specified country.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type_id</code></strong> :&ensp;<code>int</code></dt>
<dd>type of intesconnectness, 1 = economic, 2 = non economic</dd>
<dt><strong><code>country_code</code></strong> :&ensp;<code>str</code></dt>
<dd>code of country</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dict with one key interconnectness which value is list of dicts with keyscountry, value, type</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInterconnectnessData(self, type_id: int, country_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
    &#34;&#34;&#34; Returns data from table interconnectness for specified country.

            Args:
                type_id (int): type of intesconnectness, 1 = economic, 2 = non economic
                country_code (str): code of country

            Returns:
                dict: dict with one key interconnectness which value is list of dicts with keyscountry, value, type
    &#34;&#34;&#34;

    sql = &#34;select c2.code, c2.name, i.value, it.title  from interconnectness i join country c1 &#34; \
          &#34;on country_one_id = c1.id join country c2 on country_two_id = c2.id join interconnectness_type it &#34; \
          &#34;on i.type_id = it.id where i.type_id = %(type_id)s and c1.code = %(country_code)s &#34;
    result = {&#34;interconnectness&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;type_id&#34;: type_id, &#34;country_code&#34;: country_code})
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;interconnectness&#34;].append(
                        {&#34;code&#34;: tmp[0], &#34;country&#34;: tmp[1], &#34;value&#34;: tmp[2], &#34;type&#34;: tmp[3]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getMaxPoints"><code class="name flex">
<span>def <span class="ident">getMaxPoints</span></span>(<span>self) >Dict[<built-infunctionid>,float]</span>
</code></dt>
<dd>
<div class="desc"><p>Get maximum points for each country in any sport from table MAX_POINTS_IN_SPORT.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id,float]</code></dt>
<dd>dict with keys = sport ids, its value is max points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMaxPoints(self) -&gt; Dict[id, float]:
    &#34;&#34;&#34; Get maximum points for each country in any sport from table MAX_POINTS_IN_SPORT.

    Returns:
        Dict[id,float]:  dict with keys = sport ids, its value is max points
    &#34;&#34;&#34;

    sql = &#34;select sport_id, points from MAX_POINTS_IN_SPORT&#34;
    result = {&#34;points&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    sport_id, points = tmp
                    result[&#34;points&#34;].append({&#34;sport_id&#34;: sport_id, &#34;points&#34;: points})
                    tmp = cursor.fetchone()

        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        final_result = {}

        for record in result[&#34;points&#34;]:
            sport_id, points = record[&#34;sport_id&#34;], record[&#34;points&#34;]

            final_result[sport_id] = points

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getMinOrder"><code class="name flex">
<span>def <span class="ident">getMinOrder</span></span>(<span>self) >Dict[<built-infunctionid>,float]</span>
</code></dt>
<dd>
<div class="desc"><p>Get minimum = best order of country in any sport.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id, float]</code></dt>
<dd>dict of country id -&gt; order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMinOrder(self) -&gt; Dict[id, float]:
    &#34;&#34;&#34;Get minimum = best order of country in any sport.

    Returns:
        Dict[id, float]: dict of country id -&gt; order
    &#34;&#34;&#34;

    sql = &#34;select country_id, best from COUNTRY_BEST_ORDER &#34;
    result = {&#34;order&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    country_id, order = tmp
                    result[&#34;order&#34;].append({&#34;country_id&#34;: country_id, &#34;order&#34;: order})
                    tmp = cursor.fetchone()

        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        final_result = {}

        for record in result[&#34;order&#34;]:
            country_id, order = record[&#34;country_id&#34;], record[&#34;order&#34;]

            final_result[country_id] = order

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getNonCombiBranchFunding"><code class="name flex">
<span>def <span class="ident">getNonCombiBranchFunding</span></span>(<span>self) >Dict[<built-infunctionid>,Dict[<built-infunctionid>,Dict[<built-infunctionid>,float]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all funding records for NONcombi branches from table funding.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id, Dict[id, Dict[id, float]]]</code></dt>
<dd>dict of country id -&gt; dict of sport id -&gt;</dd>
</dl>
<p>dict of branch id -&gt; total non combi branch funding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNonCombiBranchFunding(self) -&gt; Dict[id, Dict[id, Dict[id, float]]]:
    &#34;&#34;&#34; Get all funding records for NONcombi branches from table funding.

    Returns:
        Dict[id, Dict[id, Dict[id, float]]]: dict of country id -&gt; dict of sport id -&gt;
        dict of branch id -&gt; total non combi branch funding
    &#34;&#34;&#34;
    sql = &#34;select f.country_id, sport_id, branch_id, sum(absolute_funding)  from funding f join branch b  &#34; \
          &#34;on b.id = f.branch_id  and is_combined = false group by f.country_id, sport_id, branch_id&#34;
    result = {&#34;funding&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    country_id, sport_id, branch_id, suma = tmp
                    result[&#34;funding&#34;].append(
                        {&#34;country_id&#34;: country_id, &#34;sport_id&#34;: sport_id, &#34;branch_id&#34;: branch_id, &#34;sum&#34;: suma})
                    tmp = cursor.fetchone()

        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        final_result = {}

        for record in result[&#34;funding&#34;]:
            country_id, sport_id, branch_id, suma = record[&#34;country_id&#34;], record[&#34;sport_id&#34;], record[&#34;branch_id&#34;], \
                                                    record[&#34;sum&#34;]

            if country_id not in final_result:
                final_result[country_id] = {}

            if sport_id not in final_result[country_id]:
                final_result[country_id][sport_id] = {}

            final_result[country_id][sport_id][branch_id] = suma

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getNonCombiBranchIds"><code class="name flex">
<span>def <span class="ident">getNonCombiBranchIds</span></span>(<span>self) >List[Dict[str,<built-infunctionid>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all ids of non combi branches in table branch.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, id]</code></dt>
<dd>list of dicts with key 'id' and value combi branch id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNonCombiBranchIds(self) -&gt; List[Dict[str, id]]:

    &#34;&#34;&#34; Returns all ids of non combi branches in table branch.

    Returns:
        Dict[str, id]: list of dicts with key &#39;id&#39; and value combi branch id
    &#34;&#34;&#34;

    sql = &#34;select id from branch where is_combined = false&#34;
    result = {&#34;branches&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;branches&#34;].append({&#34;id&#34;: tmp[0]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result[&#34;branches&#34;]</code></pre>
</details>
</dd>
<dt id="__init__.Database.getNonCombiWithSportBranchIds"><code class="name flex">
<span>def <span class="ident">getNonCombiWithSportBranchIds</span></span>(<span>self) >Dict[<built-infunctionid>,List[<built-infunctionid>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get non combi branch ids with sport it belongs to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id, List[id]]</code></dt>
<dd>dict of sport id -&gt; list of branch ids in this sport</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNonCombiWithSportBranchIds(self) -&gt; Dict[id, List[id]]:
    &#34;&#34;&#34; Get non combi branch ids with sport it belongs to.

    Returns:
        Dict[id, List[id]]: dict of sport id -&gt; list of branch ids in this sport
    &#34;&#34;&#34;
    sql = &#34;select id, sport_id from branch where is_combined = false&#34;
    result = {&#34;branches&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;branches&#34;].append({&#34;id&#34;: tmp[0], &#34;sport_id&#34;: tmp[1]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)

        final_result = {}
        for record in result[&#34;branches&#34;]:
            sport_id, id = record[&#34;sport_id&#34;], record[&#34;id&#34;]
            if sport_id not in final_result:
                final_result[sport_id] = []
            final_result[sport_id].append(id)
        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getNonEconIntercon"><code class="name flex">
<span>def <span class="ident">getNonEconIntercon</span></span>(<span>self) >Dict[<built-infunctionid>,Dict[<built-infunctionid>,float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all non economic interconnectness records from table interconnectness.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id, Dict[id, float]]</code></dt>
<dd>dict of country id -&gt; dict of country id -&gt; non econ interconnectness</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNonEconIntercon(self) -&gt; Dict[id, Dict[id, float]]:
    &#34;&#34;&#34; Returns all non economic interconnectness records from table interconnectness.

    Returns:
        Dict[id, Dict[id, float]]: dict of country id -&gt; dict of country id -&gt; non econ interconnectness
    &#34;&#34;&#34;
    sql = &#34;select country_one_id, country_two_id, value from interconnectness where type_id = 2&#34;
    result = {&#34;inter&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    country_one_id, country_two_id, value = tmp
                    result[&#34;inter&#34;].append(
                        {&#34;country_one_id&#34;: country_one_id, &#34;country_two_id&#34;: country_two_id, &#34;value&#34;: value})
                    tmp = cursor.fetchone()

        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        final_result = {}

        for record in result[&#34;inter&#34;]:
            country_one_id, country_two_id, value = record[&#34;country_one_id&#34;], record[&#34;country_two_id&#34;], record[
                &#34;value&#34;]

            if country_one_id not in final_result:
                final_result[country_one_id] = {}

            final_result[country_one_id][country_two_id] = value

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getNumCountriesInSport"><code class="name flex">
<span>def <span class="ident">getNumCountriesInSport</span></span>(<span>self) >Dict[<built-infunctionid>,int]</span>
</code></dt>
<dd>
<div class="desc"><p>Getter for table NUM_IN_SPORT which contains number of countries ranked in a sport.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id, int]</code></dt>
<dd>dict sport id -&gt; number of countries</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNumCountriesInSport(self) -&gt; Dict[id, int]:
    &#34;&#34;&#34; Getter for table NUM_IN_SPORT which contains number of countries ranked in a sport.

    Returns:
        Dict[id, int]: dict sport id -&gt; number of countries
    &#34;&#34;&#34;

    sql = &#34;select sport_id, num_countries from NUM_IN_SPORT&#34;
    result = {&#34;num&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    sport_id, num = tmp
                    result[&#34;num&#34;].append({&#34;sport_id&#34;: sport_id, &#34;num&#34;: num})
                    tmp = cursor.fetchone()

        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        final_result = {}

        for record in result[&#34;num&#34;]:
            sport_id, num = record[&#34;sport_id&#34;], record[&#34;num&#34;]

            final_result[sport_id] = num

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getOrder"><code class="name flex">
<span>def <span class="ident">getOrder</span></span>(<span>self) >Dict[int,Dict[int,int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get order of each country in each sport from table success .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[int, Dict[int, int]]</code></dt>
<dd>dict with keys = country ids, its value is dict</dd>
</dl>
<p>with items sport id -&gt; order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOrder(self) -&gt; Dict[int, Dict[int, int]]:
    &#34;&#34;&#34; Get order of each country in each sport from table success .

    Returns:
        Dict[int, Dict[int, int]]:  dict with keys = country ids, its value is dict
        with items sport id -&gt; order
    &#34;&#34;&#34;

    sql = &#34;select country_id, sport_id, orders from success&#34;
    result = {&#34;order&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    country_id, sport_id, order = tmp
                    result[&#34;order&#34;].append({&#34;country_id&#34;: country_id, &#34;sport_id&#34;: sport_id, &#34;order&#34;: order})
                    tmp = cursor.fetchone()

        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        final_result = {}

        for record in result[&#34;order&#34;]:

            country_id, sport_id, order = record[&#34;country_id&#34;], record[&#34;sport_id&#34;], record[&#34;order&#34;]

            if record[&#34;country_id&#34;] not in final_result:
                final_result[country_id] = {}

            final_result[country_id][sport_id] = order

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getPoints"><code class="name flex">
<span>def <span class="ident">getPoints</span></span>(<span>self) >Dict[<built-infunctionid>,Dict[<built-infunctionid>,float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get points of each country in each sport from table success .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code> Dict[id, Dict[id, float]]</code></dt>
<dd>dict with keys = country ids, its value is dict</dd>
</dl>
<p>with items sport id -&gt; points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPoints(self) -&gt; Dict[id, Dict[id, float]]:
    &#34;&#34;&#34; Get points of each country in each sport from table success .

    Returns:
         Dict[id, Dict[id, float]]:  dict with keys = country ids, its value is dict
        with items sport id -&gt; points
    &#34;&#34;&#34;

    sql = &#34;select country_id, sport_id, points from success&#34;
    result = {&#34;points&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    country_id, sport_id, points = tmp
                    result[&#34;points&#34;].append({&#34;country_id&#34;: country_id, &#34;sport_id&#34;: sport_id, &#34;points&#34;: points})
                    tmp = cursor.fetchone()

        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        final_result = {}

        for record in result[&#34;points&#34;]:

            country_id, sport_id, points = record[&#34;country_id&#34;], record[&#34;sport_id&#34;], record[&#34;points&#34;]

            if record[&#34;country_id&#34;] not in final_result:
                final_result[country_id] = {}

            final_result[country_id][sport_id] = points

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getSecretary"><code class="name flex">
<span>def <span class="ident">getSecretary</span></span>(<span>self, email:str) >Optional[None]</span>
</code></dt>
<dd>
<div class="desc"><p>Use in secretary login process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code></dt>
<dd>entered admin email</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[None, dict]</code></dt>
<dd>dict of record in DB which email is same as entered email</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSecretary(self, email: str) -&gt; Union[None, dict]:
    &#34;&#34;&#34; Use in secretary login process.

    Args:
        email (str): entered admin email

    Returns:
        Union[None, dict]: dict of record in DB which email is same as entered email
    &#34;&#34;&#34;

    sql = &#34;select * from users where email=%s and type=&#39;secretary&#39;&#34;
    result = None
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, (email,))
                result = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getSportBranches"><code class="name flex">
<span>def <span class="ident">getSportBranches</span></span>(<span>self, sport_code:int) >List[Dict[str,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all branches which belongs to entered sport.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected sport code</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict[str, Any]]</code></dt>
<dd>list of dicts , each dict contains keys code, title.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSportBranches(self, sport_code: int) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;Returns all branches which belongs to entered sport.

    Args:
        sport_code (int): selected sport code

    Returns:
        List[Dict[str, Any]]: list of dicts , each dict contains keys code, title.
    &#34;&#34;&#34;

    sql = &#34;select b.code, b.title from branch b join sport s &#34; \
          &#34;on b.sport_id = s.id and s.code = %(code)s&#34;
    result = {&#34;branches&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;code&#34;: sport_code})
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;branches&#34;].append({&#34;code&#34;: tmp[0], &#34;title&#34;: tmp[1]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)

    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)

    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result[&#34;branches&#34;]</code></pre>
</details>
</dd>
<dt id="__init__.Database.getSportIds"><code class="name flex">
<span>def <span class="ident">getSportIds</span></span>(<span>self) >List[Dict[str,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns sports data from table sport.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict[str, Any]]</code></dt>
<dd>list of dicts, each dict contain keys id, title = description of sport.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSportIds(self) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34; Returns sports data from table sport.

    Returns:
        List[Dict[str, Any]]: list of dicts, each dict contain keys id, title = description of sport.
    &#34;&#34;&#34;
    sql = &#34;select id, title from sport&#34;
    result = {&#34;sports&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;sports&#34;].append({&#34;id&#34;: tmp[0], &#34;title&#34;: tmp[1]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result[&#34;sports&#34;]</code></pre>
</details>
</dd>
<dt id="__init__.Database.getSportsWithExisitingBranch"><code class="name flex">
<span>def <span class="ident">getSportsWithExisitingBranch</span></span>(<span>self) >List[Dict[str,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns sports from table sport which have at least one branch.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict[str, Any]]</code></dt>
<dd>list of dicts , each dict contains keys title, code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSportsWithExisitingBranch(self) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34; Returns sports from table sport which have at least one branch.
        
    Returns:
        List[Dict[str, Any]]: list of dicts , each dict contains keys title, code.

    &#34;&#34;&#34;
    sql = &#34;select s.code, s.title from sport s &#34; \
          &#34; where exists(select * from branch where sport_id = s.id) &#34;

    sports = []
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    sports.append({&#34;title&#34;: tmp[1], &#34;code&#34;: tmp[0]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return sports</code></pre>
</details>
</dd>
<dt id="__init__.Database.getSuccessByCountry"><code class="name flex">
<span>def <span class="ident">getSuccessByCountry</span></span>(<span>self, country_code:str) >Dict[str,List[Dict[str,Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Return success records from table success for selected country.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>country_code</code></strong> :&ensp;<code>str</code></dt>
<dd>code of selected country</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dict with one key = success, its value is list of dicts, each dict contains</dd>
</dl>
<p>keys sport_name, points, order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSuccessByCountry(self, country_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
    &#34;&#34;&#34; Return success records from table success for selected country.

    Args:
        country_code (str): code of selected country

    Returns:
        dict: dict with one key = success, its value is list of dicts, each dict contains
        keys sport_name, points, order
    &#34;&#34;&#34;

    sql = &#34;select sp.title, suc.points, suc.orders from success suc cross join sport sp &#34; \
          &#34;join country c on suc.sport_id = sp.id and c.code = %(country_code)s &#34; \
          &#34;and suc.country_id = c.id order by suc.orders;&#34;
    result = {&#34;success&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;country_code&#34;: country_code})
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;success&#34;].append({&#34;sport_name&#34;: tmp[0], &#34;points&#34;: tmp[1], &#34;order&#34;: tmp[2]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getSuccessBySport"><code class="name flex">
<span>def <span class="ident">getSuccessBySport</span></span>(<span>self, sport_code:str) >Dict[str,List[Dict[str,Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Return success records from table success for selected sport.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_code</code></strong> :&ensp;<code>str</code></dt>
<dd>code of selected sport</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dict with one key = success, its value is list of dicts, each dict contains</dd>
</dl>
<p>keys country_name, points, order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSuccessBySport(self, sport_code: str) -&gt; Dict[str, List[Dict[str, Any]]]:
    &#34;&#34;&#34; Return success records from table success for selected sport.

    Args:
        sport_code (str): code of selected sport

    Returns:
        dict: dict with one key = success, its value is list of dicts, each dict contains
        keys country_name, points, order
    &#34;&#34;&#34;

    sql = &#34;select c.name, suc.points, suc.orders from success suc cross join sport sp &#34; \
          &#34;join country c on suc.sport_id = sp.id and sp.code = %(sport_code)s &#34; \
          &#34;and suc.country_id = c.id order by suc.orders;&#34;
    result = {&#34;success&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;sport_code&#34;: sport_code})
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;success&#34;].append({&#34;country_name&#34;: tmp[0], &#34;points&#34;: tmp[1], &#34;order&#34;: tmp[2]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getTotalBranchFunding"><code class="name flex">
<span>def <span class="ident">getTotalBranchFunding</span></span>(<span>self) >Dict[<built-infunctionid>,Dict[<built-infunctionid>,float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns total branch fnding = sum of direct funding and funding from combi branches.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id, Dict[id, float]]</code></dt>
<dd>dict of country id -&gt; dict of branch id -&gt; total funding</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTotalBranchFunding(self) -&gt; Dict[id, Dict[id, float]]:
    &#34;&#34;&#34;Returns total branch fnding = sum of direct funding and funding from combi branches.

    Returns:
        Dict[id, Dict[id, float]]: dict of country id -&gt; dict of branch id -&gt; total funding
    &#34;&#34;&#34;

    sql = &#34;&#34;&#34;select country_id, branch_id, sum(absolute_funding) from

        ((
            select f.country_id, branch_id, absolute_funding
            from funding f join branch b  
            on b.id = f.branch_id  and is_combined = false  
        )
        union
        (
            select b.country_id, cb.subbranch_id as branch_id, absolute_funding * coefficient as absolute_funding 
            from branch b join combi_branch cb on b.id = cb.combi_branch_id
            join funding f on f.country_id = b.country_id and f.branch_id = cb.combi_branch_id
            
        )) as x
        
        group by country_id, branch_id
        order by country_id, branch_id
        &#34;&#34;&#34;
    result = {&#34;funding&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    result[&#34;funding&#34;].append(
                        {&#34;country_id&#34;: tmp[0], &#34;branch_id&#34;: tmp[1], &#34;absolute_funding&#34;: tmp[2]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)

        final_result = {}

        for record in result[&#34;funding&#34;]:
            country_id, branch_id, absolute_funding = record[&#34;country_id&#34;], record[&#34;branch_id&#34;], record[
                &#34;absolute_funding&#34;]

            if country_id not in final_result:
                final_result[country_id] = {}

            final_result[country_id][branch_id] = absolute_funding

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.getTotalCountryPoints"><code class="name flex">
<span>def <span class="ident">getTotalCountryPoints</span></span>(<span>self) >Dict[<built-infunctionid>,float]</span>
</code></dt>
<dd>
<div class="desc"><p>Get sum of points in all sport in a country.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[id, float]</code></dt>
<dd>dict of country id -&gt; sum of points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTotalCountryPoints(self) -&gt; Dict[id, float]:
    &#34;&#34;&#34; Get sum of points in all sport in a country.

    Returns:
        Dict[id, float]: dict of country id -&gt; sum of points
    &#34;&#34;&#34;
    sql = &#34;select country_id, points from TOTAL_COUNTRY_POINTS&#34;
    result = {&#34;sum&#34;: []}
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    country_id, suma = tmp
                    result[&#34;sum&#34;].append({&#34;country_id&#34;: country_id, &#34;sum&#34;: suma})
                    tmp = cursor.fetchone()

        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        final_result = {}

        for record in result[&#34;sum&#34;]:
            country_id, suma = record[&#34;country_id&#34;], record[&#34;sum&#34;]

            final_result[country_id] = suma

        return final_result</code></pre>
</details>
</dd>
<dt id="__init__.Database.importBGSdata"><code class="name flex">
<span>def <span class="ident">importBGSdata</span></span>(<span>self, sport_id:<built-infunctionid>, value:int)</span>
</code></dt>
<dd>
<div class="desc"><p>add BGS record into database</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_id</code></strong></dt>
<dd>id representation of sport</dd>
<dt><strong><code>value</code></strong></dt>
<dd>int value of BGS</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether import was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importBGSdata(self, sport_id: id, value: int):
    &#34;&#34;&#34;add BGS record into database
               Args:
                    sport_id: id representation of sport
                    value: int value of BGS
               Returns:
                    bool: true/false whether import was successfull
    &#34;&#34;&#34;
    sql = &#34;insert into BGS(sport_id, value) &#34; \
            &#34;values (%(sport_id)s, %(value)s)&#34;

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;sport_id&#34;: sport_id,  &#34;value&#34;: value})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.importCountryBestOrder"><code class="name flex">
<span>def <span class="ident">importCountryBestOrder</span></span>(<span>self, country_id:<built-infunctionid>, best:int)</span>
</code></dt>
<dd>
<div class="desc"><p>add best placement of specific country</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>country_id</code></strong></dt>
<dd>id represenation of country,</dd>
<dt><strong><code>points</code></strong></dt>
<dd>best placement of country</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether importing was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importCountryBestOrder(self, country_id: id, best: int):
    &#34;&#34;&#34;add best placement of specific country
                     Args:
                          country_id: id represenation of country,
                          points: best placement of country
                     Returns:
                          bool: true/false whether importing was successfull
    &#34;&#34;&#34;
    sql = &#34;insert into COUNTRY_BEST_ORDER(country_id, best) &#34; \
          &#34;values (%(country_id)s, %(best)s)&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;country_id&#34;: country_id, &#34;best&#34;: best})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.importFundingData"><code class="name flex">
<span>def <span class="ident">importFundingData</span></span>(<span>self, country_id:<built-infunctionid>, branch_id:<built-infunctionid>, amount:float, currency:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds 1 fund into database.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>country_id</code></strong></dt>
<dd>id representation of country</dd>
<dt><strong><code>branch_id</code></strong></dt>
<dd>id representation of branch</dd>
<dt><strong><code>amount</code></strong></dt>
<dd>how much money was funded</dd>
<dt><strong><code>currency</code></strong></dt>
<dd>ISO 4217 of fund currency</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether importing was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importFundingData(self, country_id: id, branch_id: id, amount: float, currency: str):
    &#34;&#34;&#34;Adds 1 fund into database.

               Args:
                   country_id: id representation of country
                   branch_id: id representation of branch
                   amount: how much money was funded
                   currency: ISO 4217 of fund currency

               Returns:
                   bool: true/false whether importing was successfull
    &#34;&#34;&#34;
    sql_del = &#34;delete from funding where country_id=%(country_id)s and branch_id=%(branch_id)s&#34;

    sql = &#34;insert into funding(country_id, branch_id, absolute_funding, currency) &#34; \
          &#34;values (%(country_id)s, %(branch_id)s, %(amount)s, %(currency)s)&#34;

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql_del, {&#34;country_id&#34;: country_id, &#34;branch_id&#34;: branch_id})
                cursor.execute(sql, {&#34;country_id&#34;: country_id, &#34;branch_id&#34;: branch_id, &#34;amount&#34;: amount,
                                     &#34;currency&#34;: currency})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.importInterconnectednessData"><code class="name flex">
<span>def <span class="ident">importInterconnectednessData</span></span>(<span>self, type_id:<built-infunctionid>, country_one_id:<built-infunctionid>, country_two_id:<built-infunctionid>, value:float)</span>
</code></dt>
<dd>
<div class="desc"><p>imports interconnectedness record</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type_id</code></strong></dt>
<dd>type of interconnectedness ( 1 economic, 2 non-economic )</dd>
<dt><strong><code>country_one_id</code></strong></dt>
<dd>id representation of country</dd>
<dt><strong><code>country_two_id</code></strong></dt>
<dd>id representation of country ( they can not match )</dd>
<dt><strong><code>value</code></strong></dt>
<dd>value of interconnectedness between country1 and country2</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether deleting was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importInterconnectednessData(self, type_id: id, country_one_id: id, country_two_id: id, value: float):
    &#34;&#34;&#34;imports interconnectedness record
                          Args:
                               type_id: type of interconnectedness ( 1 economic, 2 non-economic )
                               country_one_id: id representation of country
                               country_two_id: id representation of country ( they can not match )
                               value: value of interconnectedness between country1 and country2

                          Returns:
                               bool: true/false whether deleting was successfull
    &#34;&#34;&#34;
    sql = &#34;insert into interconnectness(type_id, country_one_id, country_two_id, value ) &#34; \
          &#34;values (%(type_id)s, %(country_one_id)s, %(country_two_id)s , %(value)s)&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;type_id&#34;: type_id, &#34;country_one_id&#34;: country_one_id,
                                     &#34;country_two_id&#34;: country_two_id, &#34;value&#34;: value})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        #print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.importMaxPointsInSport"><code class="name flex">
<span>def <span class="ident">importMaxPointsInSport</span></span>(<span>self, sport_id:<built-infunctionid>, points:float)</span>
</code></dt>
<dd>
<div class="desc"><p>add highest points in specific sport</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_id</code></strong></dt>
<dd>id represenation of sport,</dd>
<dt><strong><code>points</code></strong></dt>
<dd>maximum of the points in sport</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether importing was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importMaxPointsInSport(self, sport_id: id, points: float):
    &#34;&#34;&#34;add highest points in specific sport
                     Args:
                          sport_id: id represenation of sport,
                          points: maximum of the points in sport
                     Returns:
                          bool: true/false whether importing was successfull
    &#34;&#34;&#34;
    sql = &#34;insert into MAX_POINTS_IN_SPORT(sport_id, points) &#34; \
          &#34;values (%(sport_id)s, %(points)s)&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;sport_id&#34;: sport_id, &#34;points&#34;: points})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.importNumberInSports"><code class="name flex">
<span>def <span class="ident">importNumberInSports</span></span>(<span>self, sport_id:<built-infunctionid>, num_countries:int)</span>
</code></dt>
<dd>
<div class="desc"><p>add how many sports were ranked in specific sport</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_id</code></strong></dt>
<dd>id represenation of sport,</dd>
<dt><strong><code>num_countries</code></strong></dt>
<dd>how many countries are in the success ranking</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether importing was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importNumberInSports(self, sport_id: id, num_countries: int):
    &#34;&#34;&#34;add how many sports were ranked in specific sport
               Args:
                    sport_id: id represenation of sport,
                    num_countries: how many countries are in the success ranking
               Returns:
                    bool: true/false whether importing was successfull
    &#34;&#34;&#34;
    sql = &#34;insert into NUM_IN_SPORT(sport_id, num_countries) &#34; \
          &#34;values (%(sport_id)s, %(num_countries)s)&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;sport_id&#34;: sport_id, &#34;num_countries&#34;: num_countries})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.importSuccessdata"><code class="name flex">
<span>def <span class="ident">importSuccessdata</span></span>(<span>self, sport_id:<built-infunctionid>, country_id:<built-infunctionid>, points:float, orders:int)</span>
</code></dt>
<dd>
<div class="desc"><p>add success record into DB</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_id</code></strong></dt>
<dd>id representation of sport</dd>
<dt><strong><code>country_id</code></strong></dt>
<dd>id representation of country</dd>
<dt><strong><code>points</code></strong></dt>
<dd>float, how many points did country get in sport</dd>
<dt><strong><code>orders</code></strong></dt>
<dd>int, in which place did the country ended up</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether importing was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importSuccessdata(self, sport_id: id, country_id: id, points: float, orders: int):
    &#34;&#34;&#34;add success record into DB
               Args:
                    sport_id: id representation of sport
                    country_id: id representation of country
                    points: float, how many points did country get in sport
                    orders: int, in which place did the country ended up
               Returns:
                    bool: true/false whether importing was successfull
    &#34;&#34;&#34;
    sql = &#34;insert into success(sport_id, country_id, points, orders) &#34; \
          &#34;values (%(sport_id)s, %(country_id)s, %(points)s, %(orders)s)&#34;

    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;sport_id&#34;: sport_id, &#34;country_id&#34;: country_id, &#34;points&#34;: points,
                                     &#34;orders&#34;: orders})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.importTotalCountryPoints"><code class="name flex">
<span>def <span class="ident">importTotalCountryPoints</span></span>(<span>self, country_id:<built-infunctionid>, points:float)</span>
</code></dt>
<dd>
<div class="desc"><p>add sum of points above all sports for specific country</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>country_id</code></strong></dt>
<dd>id represenation of country,</dd>
<dt><strong><code>points</code></strong></dt>
<dd>sum of points from all sports</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether importing was successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importTotalCountryPoints(self, country_id: id, points: float):
    &#34;&#34;&#34;add sum of points above all sports for specific country
                     Args:
                          country_id: id represenation of country,
                          points: sum of points from all sports
                     Returns:
                          bool: true/false whether importing was successfull
    &#34;&#34;&#34;
    sql = &#34;insert into TOTAL_COUNTRY_POINTS(country_id, points) &#34; \
          &#34;values (%(country_id)s, %(points)s)&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;country_id&#34;: country_id, &#34;points&#34;: points})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
<dt id="__init__.Database.showCombiBranches"><code class="name flex">
<span>def <span class="ident">showCombiBranches</span></span>(<span>self) >List[Dict[str,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns data about combi branches from table combi_branch.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict[str, Any]]</code></dt>
<dd>list of dicts , each dict contains keys countryCode, countryName,</dd>
</dl>
<p>combiCode, combiTitle, subCode, subTitle, coefficient</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showCombiBranches(self) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;Returns data about combi branches from table combi_branch.

    Returns:
        List[Dict[str, Any]]: list of dicts , each dict contains keys countryCode, countryName,
        combiCode, combiTitle, subCode, subTitle, coefficient
    &#34;&#34;&#34;

    sql = &#34;select c.code, c.name, b.code, b.title, b2.code, b2.title, coefficient &#34; \
          &#34;from combi_branch cb join branch b on combi_branch_id = b.id &#34; \
          &#34;join branch b2 on subbranch_id = b2.id &#34; \
          &#34;join country c on b.country_id = c.id&#34;
    results = []
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                while tmp:
                    results.append(
                        {&#34;countryCode&#34;: tmp[0], &#34;countryName&#34;: tmp[1], &#34;combiCode&#34;: tmp[2], &#34;combiTitle&#34;: tmp[3],
                         &#34;subCode&#34;: tmp[4], &#34;subTitle&#34;: tmp[5], &#34;coefficient&#34;: tmp[6]})
                    tmp = cursor.fetchone()
        # self._releaseConnection(dbConn)
    except psycopg2.DatabaseError as error:
        # print(error)
        self.logger.error(error)
    finally:
        # print(result)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return results</code></pre>
</details>
</dd>
<dt id="__init__.Database.suggestNewBranchCode"><code class="name flex">
<span>def <span class="ident">suggestNewBranchCode</span></span>(<span>self, sport_code:int) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns suggestion for branch code in entered sport.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sport_code</code></strong> :&ensp;<code>int</code></dt>
<dd>selected sport code</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>suggestion for branch code under selected sport</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suggestNewBranchCode(self, sport_code: int) -&gt; int:
    &#34;&#34;&#34; Returns suggestion for branch code in entered sport.

    Args:
        sport_code (int): selected sport code

    Returns:
        int: suggestion for branch code under selected sport
    &#34;&#34;&#34;

    sql = &#34;select max(b.code)+1 from branch b &#34; \
          &#34;join sport s on s.id = b.sport_id and s.code = %(sport_code)s&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql, {&#34;sport_code&#34;: sport_code})
                tmp = cursor.fetchone()
                if &#34;dbConn&#34; in locals():
                    self._releaseConnection(dbConn)
                return tmp[0] if tmp[0] is not None else 1
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)</code></pre>
</details>
</dd>
<dt id="__init__.Database.suggestNewCombiBranchCode"><code class="name flex">
<span>def <span class="ident">suggestNewCombiBranchCode</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns suggestion for combi branch code.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>suggestion for new combi branch code</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suggestNewCombiBranchCode(self) -&gt; int:
    &#34;&#34;&#34; Returns suggestion for combi branch code.

    Returns:
        int: suggestion for new combi branch code
    &#34;&#34;&#34;
    sql = &#34;select max(b.code)+1 from branch b where is_combined&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                if &#34;dbConn&#34; in locals():
                    self._releaseConnection(dbConn)
                return tmp[0] if tmp[0] is not None else 10000
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)</code></pre>
</details>
</dd>
<dt id="__init__.Database.suggestNewSportCode"><code class="name flex">
<span>def <span class="ident">suggestNewSportCode</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns suggestion for sport code.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>suggestion for sport code</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suggestNewSportCode(self) -&gt; int:
    &#34;&#34;&#34; Returns suggestion for sport code.

    Returns:
        int: suggestion for sport code
    &#34;&#34;&#34;

    sql = &#34;select max(code)+1 from sport&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql)
                tmp = cursor.fetchone()
                if &#34;dbConn&#34; in locals():
                    self._releaseConnection(dbConn)
                return tmp[0] if tmp[0] is not None else 1
    except psycopg2.DatabaseError as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)</code></pre>
</details>
</dd>
<dt id="__init__.Database.updateSport"><code class="name flex">
<span>def <span class="ident">updateSport</span></span>(<span>self, data:Dict[str,Any]) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Updating sport code or title or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>dict with keys oldCode, newCode newTitle which describe sport and changes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true/false whether sport was successfully updated</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateSport(self, data: Dict[str, Any]) -&gt; bool:
    &#34;&#34;&#34; Updating sport code or title or both.

    Args:
        data (dict): dict with keys oldCode, newCode newTitle which describe sport and changes

    Returns:
        bool: true/false whether sport was successfully updated
    &#34;&#34;&#34;

    if &#34;oldCode&#34; not in data:
        raise DataError(&#34;sport data do not contain old code&#34;)
    if &#34;newCode&#34; not in data:
        raise DataError(&#34;sport data do not contain new code&#34;)
    if &#34;newTitle&#34; not in data:
        raise DataError(&#34;sport data do not contain new title&#34;)

    sql_check = &#34;select id from sport where code = %(old_code)s&#34;
    sql = &#34;update sport set code=%(new_code)s, title= %(new_title)s where id= %(id)s&#34;
    try:
        with self._getConnection() as dbConn:
            with dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(sql_check, {&#34;old_code&#34;: data[&#39;oldCode&#39;]})
                tmp = cursor.fetchone()
                if tmp is None:  # sport doesnt exist
                    self._releaseConnection(dbConn)
                    raise DataError(&#34;unable to update sport, sport with entered code doesnt exist&#34;)
                cursor.execute(sql, {&#34;new_code&#34;: data[&#39;newCode&#39;], &#34;new_title&#34;: data[&#39;newTitle&#39;], &#34;id&#34;: tmp[0]})
            dbConn.commit()
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        return True
    except (psycopg2.DatabaseError, DataError) as error:
        # print(error)
        if &#34;dbConn&#34; in locals():
            self._releaseConnection(dbConn)
        self.logger.error(error)
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="__init__.DataError" href="#__init__.DataError">DataError</a></code></h4>
</li>
<li>
<h4><code><a title="__init__.Database" href="#__init__.Database">Database</a></code></h4>
<ul class="">
<li><code><a title="__init__.Database.addBranch" href="#__init__.Database.addBranch">addBranch</a></code></li>
<li><code><a title="__init__.Database.addCombiBranch" href="#__init__.Database.addCombiBranch">addCombiBranch</a></code></li>
<li><code><a title="__init__.Database.addCountry" href="#__init__.Database.addCountry">addCountry</a></code></li>
<li><code><a title="__init__.Database.addSport" href="#__init__.Database.addSport">addSport</a></code></li>
<li><code><a title="__init__.Database.branchCodeToId" href="#__init__.Database.branchCodeToId">branchCodeToId</a></code></li>
<li><code><a title="__init__.Database.checkCodeTitle" href="#__init__.Database.checkCodeTitle">checkCodeTitle</a></code></li>
<li><code><a title="__init__.Database.checkCombi" href="#__init__.Database.checkCombi">checkCombi</a></code></li>
<li><code><a title="__init__.Database.combiBranchCodeToId" href="#__init__.Database.combiBranchCodeToId">combiBranchCodeToId</a></code></li>
<li><code><a title="__init__.Database.countryCodeToID" href="#__init__.Database.countryCodeToID">countryCodeToID</a></code></li>
<li><code><a title="__init__.Database.createDatabaseBackup" href="#__init__.Database.createDatabaseBackup">createDatabaseBackup</a></code></li>
<li><code><a title="__init__.Database.deleteBGS" href="#__init__.Database.deleteBGS">deleteBGS</a></code></li>
<li><code><a title="__init__.Database.deleteInterconnectednessTables" href="#__init__.Database.deleteInterconnectednessTables">deleteInterconnectednessTables</a></code></li>
<li><code><a title="__init__.Database.deleteSuccesTables" href="#__init__.Database.deleteSuccesTables">deleteSuccesTables</a></code></li>
<li><code><a title="__init__.Database.findBranchByCode" href="#__init__.Database.findBranchByCode">findBranchByCode</a></code></li>
<li><code><a title="__init__.Database.findSportByCode" href="#__init__.Database.findSportByCode">findSportByCode</a></code></li>
<li><code><a title="__init__.Database.getActiveCountryIds" href="#__init__.Database.getActiveCountryIds">getActiveCountryIds</a></code></li>
<li><code><a title="__init__.Database.getActiveCountryTranslations" href="#__init__.Database.getActiveCountryTranslations">getActiveCountryTranslations</a></code></li>
<li><code><a title="__init__.Database.getAdmin" href="#__init__.Database.getAdmin">getAdmin</a></code></li>
<li><code><a title="__init__.Database.getAllCountries" href="#__init__.Database.getAllCountries">getAllCountries</a></code></li>
<li><code><a title="__init__.Database.getAllSportInfo" href="#__init__.Database.getAllSportInfo">getAllSportInfo</a></code></li>
<li><code><a title="__init__.Database.getAllSports" href="#__init__.Database.getAllSports">getAllSports</a></code></li>
<li><code><a title="__init__.Database.getBGS" href="#__init__.Database.getBGS">getBGS</a></code></li>
<li><code><a title="__init__.Database.getBranchesWithSports" href="#__init__.Database.getBranchesWithSports">getBranchesWithSports</a></code></li>
<li><code><a title="__init__.Database.getCombiFunding" href="#__init__.Database.getCombiFunding">getCombiFunding</a></code></li>
<li><code><a title="__init__.Database.getEconIntercon" href="#__init__.Database.getEconIntercon">getEconIntercon</a></code></li>
<li><code><a title="__init__.Database.getFundingData" href="#__init__.Database.getFundingData">getFundingData</a></code></li>
<li><code><a title="__init__.Database.getFundingDistinctCurrencies" href="#__init__.Database.getFundingDistinctCurrencies">getFundingDistinctCurrencies</a></code></li>
<li><code><a title="__init__.Database.getInactiveCountries" href="#__init__.Database.getInactiveCountries">getInactiveCountries</a></code></li>
<li><code><a title="__init__.Database.getInterconnTypes" href="#__init__.Database.getInterconnTypes">getInterconnTypes</a></code></li>
<li><code><a title="__init__.Database.getInterconnectnessData" href="#__init__.Database.getInterconnectnessData">getInterconnectnessData</a></code></li>
<li><code><a title="__init__.Database.getMaxPoints" href="#__init__.Database.getMaxPoints">getMaxPoints</a></code></li>
<li><code><a title="__init__.Database.getMinOrder" href="#__init__.Database.getMinOrder">getMinOrder</a></code></li>
<li><code><a title="__init__.Database.getNonCombiBranchFunding" href="#__init__.Database.getNonCombiBranchFunding">getNonCombiBranchFunding</a></code></li>
<li><code><a title="__init__.Database.getNonCombiBranchIds" href="#__init__.Database.getNonCombiBranchIds">getNonCombiBranchIds</a></code></li>
<li><code><a title="__init__.Database.getNonCombiWithSportBranchIds" href="#__init__.Database.getNonCombiWithSportBranchIds">getNonCombiWithSportBranchIds</a></code></li>
<li><code><a title="__init__.Database.getNonEconIntercon" href="#__init__.Database.getNonEconIntercon">getNonEconIntercon</a></code></li>
<li><code><a title="__init__.Database.getNumCountriesInSport" href="#__init__.Database.getNumCountriesInSport">getNumCountriesInSport</a></code></li>
<li><code><a title="__init__.Database.getOrder" href="#__init__.Database.getOrder">getOrder</a></code></li>
<li><code><a title="__init__.Database.getPoints" href="#__init__.Database.getPoints">getPoints</a></code></li>
<li><code><a title="__init__.Database.getSecretary" href="#__init__.Database.getSecretary">getSecretary</a></code></li>
<li><code><a title="__init__.Database.getSportBranches" href="#__init__.Database.getSportBranches">getSportBranches</a></code></li>
<li><code><a title="__init__.Database.getSportIds" href="#__init__.Database.getSportIds">getSportIds</a></code></li>
<li><code><a title="__init__.Database.getSportsWithExisitingBranch" href="#__init__.Database.getSportsWithExisitingBranch">getSportsWithExisitingBranch</a></code></li>
<li><code><a title="__init__.Database.getSuccessByCountry" href="#__init__.Database.getSuccessByCountry">getSuccessByCountry</a></code></li>
<li><code><a title="__init__.Database.getSuccessBySport" href="#__init__.Database.getSuccessBySport">getSuccessBySport</a></code></li>
<li><code><a title="__init__.Database.getTotalBranchFunding" href="#__init__.Database.getTotalBranchFunding">getTotalBranchFunding</a></code></li>
<li><code><a title="__init__.Database.getTotalCountryPoints" href="#__init__.Database.getTotalCountryPoints">getTotalCountryPoints</a></code></li>
<li><code><a title="__init__.Database.importBGSdata" href="#__init__.Database.importBGSdata">importBGSdata</a></code></li>
<li><code><a title="__init__.Database.importCountryBestOrder" href="#__init__.Database.importCountryBestOrder">importCountryBestOrder</a></code></li>
<li><code><a title="__init__.Database.importFundingData" href="#__init__.Database.importFundingData">importFundingData</a></code></li>
<li><code><a title="__init__.Database.importInterconnectednessData" href="#__init__.Database.importInterconnectednessData">importInterconnectednessData</a></code></li>
<li><code><a title="__init__.Database.importMaxPointsInSport" href="#__init__.Database.importMaxPointsInSport">importMaxPointsInSport</a></code></li>
<li><code><a title="__init__.Database.importNumberInSports" href="#__init__.Database.importNumberInSports">importNumberInSports</a></code></li>
<li><code><a title="__init__.Database.importSuccessdata" href="#__init__.Database.importSuccessdata">importSuccessdata</a></code></li>
<li><code><a title="__init__.Database.importTotalCountryPoints" href="#__init__.Database.importTotalCountryPoints">importTotalCountryPoints</a></code></li>
<li><code><a title="__init__.Database.showCombiBranches" href="#__init__.Database.showCombiBranches">showCombiBranches</a></code></li>
<li><code><a title="__init__.Database.suggestNewBranchCode" href="#__init__.Database.suggestNewBranchCode">suggestNewBranchCode</a></code></li>
<li><code><a title="__init__.Database.suggestNewCombiBranchCode" href="#__init__.Database.suggestNewCombiBranchCode">suggestNewCombiBranchCode</a></code></li>
<li><code><a title="__init__.Database.suggestNewSportCode" href="#__init__.Database.suggestNewSportCode">suggestNewSportCode</a></code></li>
<li><code><a title="__init__.Database.updateSport" href="#__init__.Database.updateSport">updateSport</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
